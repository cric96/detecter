{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the detectEr tutorial! What is detectEr? detectEr is a runtime verification tool for asynchronous component systems. It is the product of five years of theoretical and practical development. Publications List of publications. Our group Our research group, ICE-TCS, resides at Reykjav\u00edk University, and consists of these members who actively contribute towards the theoretical and practical developments of detectEr: Luca Aceto Antonis Achilleos Duncan Paul Attard Adrian Francalanza Karoliina Lehtinen Anna Ing\u00f3lfsd\u00f3ttir detectEr is part of the TheoFoMon and MoVeMnt projects funded by the Icelandic Research Fund . Duncan Paul Attard\u2014the principal developer of the detectEr\u2014has worked as a software developer in the Telecoms and Online payment industry for seven years prior to joining the academia. Help us Please help us improve this tutorial and the tool detectEr! We would appreciate if any typos or bugs found are reported on the issues page on GitHub.","title":"Home"},{"location":"index.html#welcome-to-the-detecter-tutorial","text":"","title":"Welcome to the detectEr tutorial!"},{"location":"index.html#what-is-detecter","text":"detectEr is a runtime verification tool for asynchronous component systems. It is the product of five years of theoretical and practical development.","title":"What is detectEr?"},{"location":"index.html#publications","text":"List of publications.","title":"Publications"},{"location":"index.html#our-group","text":"Our research group, ICE-TCS, resides at Reykjav\u00edk University, and consists of these members who actively contribute towards the theoretical and practical developments of detectEr: Luca Aceto Antonis Achilleos Duncan Paul Attard Adrian Francalanza Karoliina Lehtinen Anna Ing\u00f3lfsd\u00f3ttir detectEr is part of the TheoFoMon and MoVeMnt projects funded by the Icelandic Research Fund . Duncan Paul Attard\u2014the principal developer of the detectEr\u2014has worked as a software developer in the Telecoms and Online payment industry for seven years prior to joining the academia.","title":"Our group"},{"location":"index.html#help-us","text":"Please help us improve this tutorial and the tool detectEr! We would appreciate if any typos or bugs found are reported on the issues page on GitHub.","title":"Help us"},{"location":"about.html","text":"Turba falsi florem Labentibus corpore nostra Lorem markdownum amplexa rector ora facies lumina sit lurida rursusque terruerat caelebs, diem. Contigit tortoque terebrata flore! daemon_soft_syn = e; overclocking = favicon; if (2 == windows(device, gifServer)) { primary *= botnetT; uncIntegrated(2 + ajax_trim_multiplatform, 664619 - internet_gigabyte_system, sampling_metal_copy); kindle = cronServerPpi; } boot_modem(1, onlineUtility, media - virtualization_trackball - macByteClip); Ab sonus: obruta nimium loco, bis nascendi nautae, solus cur ille turbamque damnatura turba madefactaque nescit Lacedaemoniumque . Ratibus iugulaberis, vetus ulla ubicumque opposui medicamina addita solacia iniusti amplexuque interque, admonitu nunc extendi sol. Nomina parentes potentum conplectitur socio, et dives adice et subit patriaeque crederet. Laesi saecula, dextrae; carpit dolos suspiria probro pendere simul hospita Gorgoneum. Accipe timeri nupsi fuit nostros quid memorem pellite metuunt: Harpalos positis plectrumque somno qui, ter falsa diversa motaque. Cum cum hic fugientibus vaccae de noluit sulphura cantu utque inmensi scopulum , vestra. Undis quotiens veteris nostro iube blanditiis nihil huc latus, igne inpune voluit, abiit, est Acmon viri. Exemplo capiebant o vocabula iusta; incubuitque interius ripas. Genitore sumptaque haud domos recens, pietas ille Zanclen secum; ferox ilice demittere cortice? Glomerari licet io protinus colubris vires egissem Margine de prisca fulvis miserae in illa claroque. Apolline auras ramum fitque quoque artifices oblivia nigraque freta croceum fauce et feres: nec pyra nec vertice: vincloque. Emittere dixit. Ut populis negarunt occuluit simili ne coepit Dianae quinquennia erat scrobe speciosam. Genitor qui terra mutasse nigro ! Glaebae stetit ab a arsit ignibus digna ulcisci repressit: opem arma petis, timendi hos omni et arma puerosque. Faciem conpleat mediis, Capitolia videndo ab aurumque, clamant et mihi bubo praebetis pater viscera deus. Sed pugman, nihil laudatve cervice videri. Alas oris Thetis est superis a picto nulla gente solebat a ossibus quoque! Et suis, quae Cyllenide imoque at, quisquis nulli, repetitum. Silvas est absens negata faciat iamque putant; re et, qua dixit. Excutis adsiduae Lyncides. Suis Sithon vocat pennis lupo fallitis potuit inrorant laetoque. Hic raptores possunt fatebor cornum usa.","title":"Turba falsi florem"},{"location":"about.html#turba-falsi-florem","text":"","title":"Turba falsi florem"},{"location":"about.html#labentibus-corpore-nostra","text":"Lorem markdownum amplexa rector ora facies lumina sit lurida rursusque terruerat caelebs, diem. Contigit tortoque terebrata flore! daemon_soft_syn = e; overclocking = favicon; if (2 == windows(device, gifServer)) { primary *= botnetT; uncIntegrated(2 + ajax_trim_multiplatform, 664619 - internet_gigabyte_system, sampling_metal_copy); kindle = cronServerPpi; } boot_modem(1, onlineUtility, media - virtualization_trackball - macByteClip); Ab sonus: obruta nimium loco, bis nascendi nautae, solus cur ille turbamque damnatura turba madefactaque nescit Lacedaemoniumque . Ratibus iugulaberis, vetus ulla ubicumque opposui medicamina addita solacia iniusti amplexuque interque, admonitu nunc extendi sol. Nomina parentes potentum conplectitur socio, et dives adice et subit patriaeque crederet. Laesi saecula, dextrae; carpit dolos suspiria probro pendere simul hospita Gorgoneum. Accipe timeri nupsi fuit nostros quid memorem pellite metuunt: Harpalos positis plectrumque somno qui, ter falsa diversa motaque. Cum cum hic fugientibus vaccae de noluit sulphura cantu utque inmensi scopulum , vestra. Undis quotiens veteris nostro iube blanditiis nihil huc latus, igne inpune voluit, abiit, est Acmon viri. Exemplo capiebant o vocabula iusta; incubuitque interius ripas. Genitore sumptaque haud domos recens, pietas ille Zanclen secum; ferox ilice demittere cortice?","title":"Labentibus corpore nostra"},{"location":"about.html#glomerari-licet-io-protinus-colubris-vires-egissem","text":"Margine de prisca fulvis miserae in illa claroque. Apolline auras ramum fitque quoque artifices oblivia nigraque freta croceum fauce et feres: nec pyra nec vertice: vincloque. Emittere dixit. Ut populis negarunt occuluit simili ne coepit Dianae quinquennia erat scrobe speciosam. Genitor qui terra mutasse nigro ! Glaebae stetit ab a arsit ignibus digna ulcisci repressit: opem arma petis, timendi hos omni et arma puerosque. Faciem conpleat mediis, Capitolia videndo ab aurumque, clamant et mihi bubo praebetis pater viscera deus. Sed pugman, nihil laudatve cervice videri. Alas oris Thetis est superis a picto nulla gente solebat a ossibus quoque! Et suis, quae Cyllenide imoque at, quisquis nulli, repetitum. Silvas est absens negata faciat iamque putant; re et, qua dixit. Excutis adsiduae Lyncides. Suis Sithon vocat pennis lupo fallitis potuit inrorant laetoque. Hic raptores possunt fatebor cornum usa.","title":"Glomerari licet io protinus colubris vires egissem"},{"location":"erlang.html","text":"This is a test with calc_server : loop (_) monitor and ([_ Launcher <- _ Server , calc_server : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B ] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). with 'Elixir.Demo.CalcServer' : loop (_) monitor and ([_ Launcher <- _ Server , 'Elixir.Demo.CalcServer' : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B and is_integer ( A )] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). 1 2 3 4 5 6 7 fun ( Var ) -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end The range () function is used to generate a sequence of numbers. Ctrl + Alt + Del Ctrl + V + Tab + Enter + Cmd Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Hello Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Unordered List Example : * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci The HTML specification is maintained by the W3C . Duncan \\[ \\operatorname{ker} f=\\{g\\in {\\color{sepia}{G}}:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"This is a test"},{"location":"erlang.html#this-is-a-test","text":"with calc_server : loop (_) monitor and ([_ Launcher <- _ Server , calc_server : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B ] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). with 'Elixir.Demo.CalcServer' : loop (_) monitor and ([_ Launcher <- _ Server , 'Elixir.Demo.CalcServer' : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B and is_integer ( A )] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). 1 2 3 4 5 6 7 fun ( Var ) -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end The range () function is used to generate a sequence of numbers. Ctrl + Alt + Del Ctrl + V + Tab + Enter + Cmd Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Hello Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Unordered List Example : * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci The HTML specification is maintained by the W3C . Duncan \\[ \\operatorname{ker} f=\\{g\\in {\\color{sepia}{G}}:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"This is a test"},{"location":"getting-started/preparation.html","text":"Preparation Prerequisites This tutorial assumes that users are running Ubuntu/Debian, macOS or Windows 10. Windows 10 users may either install the Windows Subsystem for Linux and follow the instructions given below for Ubuntu/Debian , or alternatively, configure Chocolatey and install the software packages mentioned via choco install . However, our instructions will not detail how detectEr is installed and used on Windows systems. Please install the software package management system available for your particular operating system before proceeding with the rest of the guide. Operating System Package Manager Installation Ubuntu/Debian APT Not required, comes pre-bundled macOS Homebrew Follow the Homebrew guide for installation Windows 10 Chocolatey Follow the Chocolatey guide for installation Installing Erlang Erlang can be installed on multiple platforms by compiling it from source or downloading one of the pre-compiled distributions hosted on erlang-solutions.com . We however follow the simpler route and install Erlang using the package managers mentioned above. Ubuntu/Debian On Ubuntu and Debian, Erlang can be installed using APT . Add the Erlang Solutions repository: wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb sudo dpkg -i erlang-solutions_2.0_all.deb Refresh the package manager repository cache: sudo apt update . Install the entire Erlang/ OTP suite only: sudo apt install erlang . macOS macOS users can install the entire Erlang/ OTP suite using Homebrew by running: brew install erlang . Windows 10 Windows 10 users not using WSL can install the entire Erlang/ OTP suite using Chocolatey by running: choco install erlang . Others Refer to the Erlang Solutions guide for installing Erlang/ OTP on other operating systems. Quick check Confirm that Erlang/ OTP distribution has been successfully installed and that the system PATH variable is properly configured by typing erl --version . Installing Elixir Elixir runs on the Erlang virtual machine and uses the same OTP libraries. We already installed the Erlang ecosystem, and need only install the Elixir language libraries. Ubuntu/Debian On Ubuntu and Debian, Elixir can be installed via APT using: sudo apt-get install elixir . macOS macOS users can install Elixir using Homebrew by running: brew install elixir . Windows 10 Windows 10 users not using WSL can install Elixir using Chocolatey by running: choco install elixir . Others Refer to the Elixir Lang guide for installing Elixir on other operating systems. Quick check Confirm that Elixir has been successfully installed and that the system PATH variable is properly configured by typing elixir --version . Installing Python We also make use of Python 3, that can be installed as explained below. Ubuntu/Debian Most distributions of Ubuntu and Debian come with Python pre-installed. Check the version of Python available on your operating system by executing python --version . If the reported version is older than 3.7.x or Python is not installed, follow these steps. Refresh the package manager repository cache (if not already done): sudo apt update . Install Python 3: sudo apt install python3.9 . Install the Python package manager PIP : sudo apt install python3-pip . Also install the core development support tools: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev . macOS macOS comes pre-installed with Python 2.7, which is not the version we use in this tutorial. Install Python 3 via Homebrew by typing: brew install python3 . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Windows 10 Windows 10 users not using WSL can install Python 3 via Chocolatey by typing: choco install python . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Others Refer to the Real Python guide for installing Python 3 on other operating systems. Quick check Confirm that Python 3 has been successfully installed and that the system PATH variable is properly configured by typing python3 --version . Also check that PIP for Python 3 has been installed, pip3 --version . Installing the virtual environment management tool Virtualenv is a tool used to create isolated Python environments. The environment it creates has its own installation directory, and does not share libraries with other Virtualenv environments. Virtualenv can be installed via PIP : pip3 install virtualenv . Configuring Visual Studio Code Any plain text editor can be used, but for this tutorial we opt for Visual Studio Code that can be downloaded from https://code.visualstudio.com . It can also be installed using the respective operating system package manager. Ubuntu/Debian On Ubuntu and Debian, VS Code can be installed using APT . Install APT transport for downloading packages via HTTPS: sudo apt install apt-transport-https to check Import the Microsoft GPG key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository by typing: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/code stable main\" Refresh the package manager repository cache: sudo apt update . Install VS Code: sudo apt install code . macOS macOS users can install VS Code using Homebrew by running: brew install --cask visual-studio-code . Windows 10 Windows 10 users not using WSL can install VS Code using Chocolatey by running: choco install vscode . Others Refer to the Visual Studio Code guide for installing it on other operating systems. Adding extensions To enable syntax highlighting and language support for the languages used in this tutorial, VS Code can be configured with these extensions. Erlang . Elixir . Python . sHML syntax highlighting? Versions These distribution versions are used in this tutorial. Your installed versions need not exactly match, but we document these in case of any problems you might face when working through the tutorial later on. Name Version Erlang/ OTP 23.3.2 Elixir 1.11.4 Python 3.9.4 PIP 21.0.1 VS Code 1.56.0","title":"Preparation"},{"location":"getting-started/preparation.html#preparation","text":"","title":"Preparation"},{"location":"getting-started/preparation.html#prerequisites","text":"This tutorial assumes that users are running Ubuntu/Debian, macOS or Windows 10. Windows 10 users may either install the Windows Subsystem for Linux and follow the instructions given below for Ubuntu/Debian , or alternatively, configure Chocolatey and install the software packages mentioned via choco install . However, our instructions will not detail how detectEr is installed and used on Windows systems. Please install the software package management system available for your particular operating system before proceeding with the rest of the guide. Operating System Package Manager Installation Ubuntu/Debian APT Not required, comes pre-bundled macOS Homebrew Follow the Homebrew guide for installation Windows 10 Chocolatey Follow the Chocolatey guide for installation","title":"Prerequisites"},{"location":"getting-started/preparation.html#installing-erlang","text":"Erlang can be installed on multiple platforms by compiling it from source or downloading one of the pre-compiled distributions hosted on erlang-solutions.com . We however follow the simpler route and install Erlang using the package managers mentioned above. Ubuntu/Debian On Ubuntu and Debian, Erlang can be installed using APT . Add the Erlang Solutions repository: wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb sudo dpkg -i erlang-solutions_2.0_all.deb Refresh the package manager repository cache: sudo apt update . Install the entire Erlang/ OTP suite only: sudo apt install erlang . macOS macOS users can install the entire Erlang/ OTP suite using Homebrew by running: brew install erlang . Windows 10 Windows 10 users not using WSL can install the entire Erlang/ OTP suite using Chocolatey by running: choco install erlang . Others Refer to the Erlang Solutions guide for installing Erlang/ OTP on other operating systems. Quick check Confirm that Erlang/ OTP distribution has been successfully installed and that the system PATH variable is properly configured by typing erl --version .","title":"Installing Erlang"},{"location":"getting-started/preparation.html#installing-elixir","text":"Elixir runs on the Erlang virtual machine and uses the same OTP libraries. We already installed the Erlang ecosystem, and need only install the Elixir language libraries. Ubuntu/Debian On Ubuntu and Debian, Elixir can be installed via APT using: sudo apt-get install elixir . macOS macOS users can install Elixir using Homebrew by running: brew install elixir . Windows 10 Windows 10 users not using WSL can install Elixir using Chocolatey by running: choco install elixir . Others Refer to the Elixir Lang guide for installing Elixir on other operating systems. Quick check Confirm that Elixir has been successfully installed and that the system PATH variable is properly configured by typing elixir --version .","title":"Installing Elixir"},{"location":"getting-started/preparation.html#installing-python","text":"We also make use of Python 3, that can be installed as explained below. Ubuntu/Debian Most distributions of Ubuntu and Debian come with Python pre-installed. Check the version of Python available on your operating system by executing python --version . If the reported version is older than 3.7.x or Python is not installed, follow these steps. Refresh the package manager repository cache (if not already done): sudo apt update . Install Python 3: sudo apt install python3.9 . Install the Python package manager PIP : sudo apt install python3-pip . Also install the core development support tools: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev . macOS macOS comes pre-installed with Python 2.7, which is not the version we use in this tutorial. Install Python 3 via Homebrew by typing: brew install python3 . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Windows 10 Windows 10 users not using WSL can install Python 3 via Chocolatey by typing: choco install python . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Others Refer to the Real Python guide for installing Python 3 on other operating systems. Quick check Confirm that Python 3 has been successfully installed and that the system PATH variable is properly configured by typing python3 --version . Also check that PIP for Python 3 has been installed, pip3 --version .","title":"Installing Python"},{"location":"getting-started/preparation.html#installing-the-virtual-environment-management-tool","text":"Virtualenv is a tool used to create isolated Python environments. The environment it creates has its own installation directory, and does not share libraries with other Virtualenv environments. Virtualenv can be installed via PIP : pip3 install virtualenv .","title":"Installing the virtual environment management tool"},{"location":"getting-started/preparation.html#configuring-visual-studio-code","text":"Any plain text editor can be used, but for this tutorial we opt for Visual Studio Code that can be downloaded from https://code.visualstudio.com . It can also be installed using the respective operating system package manager. Ubuntu/Debian On Ubuntu and Debian, VS Code can be installed using APT . Install APT transport for downloading packages via HTTPS: sudo apt install apt-transport-https to check Import the Microsoft GPG key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository by typing: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/code stable main\" Refresh the package manager repository cache: sudo apt update . Install VS Code: sudo apt install code . macOS macOS users can install VS Code using Homebrew by running: brew install --cask visual-studio-code . Windows 10 Windows 10 users not using WSL can install VS Code using Chocolatey by running: choco install vscode . Others Refer to the Visual Studio Code guide for installing it on other operating systems.","title":"Configuring Visual Studio Code"},{"location":"getting-started/preparation.html#adding-extensions","text":"To enable syntax highlighting and language support for the languages used in this tutorial, VS Code can be configured with these extensions. Erlang . Elixir . Python . sHML syntax highlighting? Versions These distribution versions are used in this tutorial. Your installed versions need not exactly match, but we document these in case of any problems you might face when working through the tutorial later on. Name Version Erlang/ OTP 23.3.2 Elixir 1.11.4 Python 3.9.4 PIP 21.0.1 VS Code 1.56.0","title":"Adding extensions"},{"location":"getting-started/quickstart.html","text":"Quickstart Launching detectEr from the shell The detecter/ebin directory created previously needs to be included in the Erlang runtime path to preload all the binaries required to be able to use detectEr. This is done by using the -pa switch when launching the Erlang shell. [duncan@local]:$ erl -pa /path/to/detecter/ebin Once loaded, detectEr can be used to monitor systems that execute on the Erlang Virtual Machine. It also supports the monitoring of systems that run outside of the EVM , provided that these record their logs in files following a predetermined formatting that enables detectEr to extract runtime information. This topic is covered in more depth in the Instrumentation section. For now, we establish the workflow required to use detectEr by way of the traditional \u2018hello world\u2019 example. Hello world Before using detectEr, you should get an intuitive grasp of what monitoring is, and the steps one needs to follow to initialise and start the monitoring process. If this is your first time using Erlang, the following wil help you get acquainted with the Erlang shell. Launch a new terminal emulator window ( e.g. Terminal on Ubuntu or macOS), navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. BEAM files are (fairly) portable binaries consisting of bytecode that is interpreted by the EVM , similar to how Java operates. [duncan@local]:/detecter/examples/erlang$ make rm -f ebin/*.beam ebin/*.E ebin/*.tmp erl_crash.dump ebin/*.app ... [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 7 duncan duncan 224 May 17 17:16 ebin drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src 3. Launch the Erlang shell erl . We add the binaries of the ebin directory to the Erlang code path via the -pa flag to load and make them accessible from the shell. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> 4. The Erlang shell allows you to type expressions and execute them by pressing Enter . Every expression typed on the shell must be terminated with a full-stop. Try invoking the function greet of the hello module. The function greet accepts one argument, the name of the person to greet, specified as a string enclosed within double quotes. 1 > hello : greet ( \"Duncan\" ). Hello there , Duncan ! ok 2 > 5. Quit the Erlang shell by typing q(). Function signatures In Erlang (and Elixir), functions are uniquely identified via the triple mod : fun / arity , where mod is the module name, fun , the name of the function contained in the module, and arity , the number of arguments that the function accepts. This reference format is commonly known as MFA . For example, our greet function inside the module hello can be concisely referred to as hello : greet / 1 . Hello world, the asynchronous way You might have noticed that hello : greet / 1 pauses the Erlang shell momentarily before the greeting is displayed. During this interval, the shell is inoperable and cannot accept user input. Such function calls are called synchronous invocations, since they block the caller until the called function returns, i.e. the body of the called function is executed in its entirety and a value is returned to the caller. Examining the body of greet below makes it clear why the Erlang shell stops responding when the function call is effected. 1 2 3 greet ( Name ) -> timer : sleep ( 5000 ), % Pause for 5 seconds to simulate some work.. io : format ( \"Hello there, ~s ! ~n \" , [ Name ]). Line 1 defines the function greet that accepts Name as parameter, while line 3 prints the greeting on the Erlang shell via call to io : format / 2 . The call timer : sleep ( 5000 ) on line 2 pauses the caller process ( i.e. the Erlang shell, in this case) for 5000 ms before executing the rest of the function body. In Erlang, the function return value is the result of the last expression in the function body; for the case of greet , this value is the atom ok that is returned by io : format / 2 . Synchronous calls Synchronous function calls are useful when one needs to ensure that certain processes execute in some prescribed order with respect to one another, e.g. in lock step. This mode of interaction is common to many standard communication protocols such as HTTP , SMTP , DNS , etc. Unwanted synchrony can be easily avoided by launching functions to execute as independent processes that run concurrently with other processes in the system. To this end, Erlang provides the Built-in Functions spawn / { 1 - 4 } , and their variations. We slightly tweak our hello world example to spawn hello : greet / 1 as a separate process that executes concurrently with the Erlang shell process. 4 5 start_greet ( Name ) when is_list ( Name ) -> spawn ( ? MODULE , greet , [ Name ]). The function hello : start_greet / 1 implements this modification. It uses the BIF spawn / 3 (line 2 ) to launch the hello : greet / 1 function as a process, returning its process ID. The Process ID (also called the PID ) is a triple that uniquely identifies an Erlang process executing on the EVM . Function start_greet makes use of the predefined macro ? MODULE , that gets replaced with the name of the module it appears in when the source code of the hello module is preprocessed by the Erlang compiler. Concretely, the invocation to spawn/3 on line 5 yields the source code spawn ( hello , greet , [ Name ]) prior to compilation. Restart the Erlang shell and invoke hello : start_greet / 1 . 1 > hello : start_greet ( \"Duncan\" ). < 0 . 84 . 0 > Hello there , Duncan ! % Shown after a slight pause. 2 > Observe that now: The return value of start_greet is the PID <0.84.0> instead of the atom ok ; The Erlang shell does not block, but returns immediately; After the predefined sleep time elapses, the greeting is printed to the shell. Outline runtime monitoring In this quickstart demo, we monitor the execution of our asynchronous hello world example using the outline form of instrumentation. Launch the shell as previous, adding the hello world binaries in ebin to the Erlang code path. The detectEr binaries compiled earlier are also included. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> Compile the sample hello_prop.hml property script to generate the corresponding analyser binary. 1 > hml_eval : compile ( \"props/hello_prop.hml\" , [{ outdir , \"ebin\" }, v ]). This compilation procedure, known as the synthesis , translates sHML specifications written in *.hml script files to their analyser equivalents. For now, it suffices to know that sHML \u2014the logic used by detectEr\u2014expresses properties of the system one wishes to runtime verify. Our analyser Erlang binary generated from the sample property is placed in /detecter/examples/erlang/ebin and automatically loaded for use in the shell code path. 2 > ls ( \"ebin\" ). hello . beam hello_prop . beam ... The analyser hello_prop exposes a single function, mfa_spec / 1 , that accepts the MFArgs triple { Mod , Fun , Args } designating the Erlang process to be analysed. Specifically, Mod , Fun and Args are the components of the function passed as arguments to spawn / 3 . For our hello world example, Mod is the atom hello , Fun is the function name greet , and Args , the singleton argument list containing the name of the person to be greeted. You can test hello_prop : mfa_spec / 1 analyser function by providing the triple { hello , greet , [ \"Duncan\" ]} . 3 > hello_prop : mfa_spec ({ hello , greet ,[ \"Duncan\" ]}). *** [ < 0 . 82 . 0 > ] Instrumenting monitor for MFA pattern '{hello,greet,[\"Duncan\"]}' . *** [ < 0 . 82 . 0 > ] Reached verdict 'no' . Launch the monitored system. 4 > monitor : start_online ({ hello , start_greet ,[ \"Duncan\" ]}, fun hello_prop : mfa_spec / 1 , []). % (1) The function monitor : start_online / 3 accepts three arguments: a MFArgs describing the function that is to be spawned as an Erlang process, the analyser function, and a list of options . Setting MFArgs to { hello , start_greet ,[ \"Duncan\" ]} and the analyser to fun hello_prop : mfa_spec / 1 launches the hello world and analyser processes to execute concurrently. In the simple instance of the analyser hello_prop , monitoring terminates promptly with the verdict no as soon as the system starts executing. This no verdict informs us that our hello world program violated the sHML specification in hello_prop.hml . We next learn how sHML can be used to express useful properties that precisely and unambiguously describe the behaviour we want our systems not to infringe.","title":"Quickstart"},{"location":"getting-started/quickstart.html#quickstart","text":"","title":"Quickstart"},{"location":"getting-started/quickstart.html#launching-detecter-from-the-shell","text":"The detecter/ebin directory created previously needs to be included in the Erlang runtime path to preload all the binaries required to be able to use detectEr. This is done by using the -pa switch when launching the Erlang shell. [duncan@local]:$ erl -pa /path/to/detecter/ebin Once loaded, detectEr can be used to monitor systems that execute on the Erlang Virtual Machine. It also supports the monitoring of systems that run outside of the EVM , provided that these record their logs in files following a predetermined formatting that enables detectEr to extract runtime information. This topic is covered in more depth in the Instrumentation section. For now, we establish the workflow required to use detectEr by way of the traditional \u2018hello world\u2019 example.","title":"Launching detectEr from the shell"},{"location":"getting-started/quickstart.html#hello-world","text":"Before using detectEr, you should get an intuitive grasp of what monitoring is, and the steps one needs to follow to initialise and start the monitoring process. If this is your first time using Erlang, the following wil help you get acquainted with the Erlang shell. Launch a new terminal emulator window ( e.g. Terminal on Ubuntu or macOS), navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. BEAM files are (fairly) portable binaries consisting of bytecode that is interpreted by the EVM , similar to how Java operates. [duncan@local]:/detecter/examples/erlang$ make rm -f ebin/*.beam ebin/*.E ebin/*.tmp erl_crash.dump ebin/*.app ... [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 7 duncan duncan 224 May 17 17:16 ebin drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src 3. Launch the Erlang shell erl . We add the binaries of the ebin directory to the Erlang code path via the -pa flag to load and make them accessible from the shell. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> 4. The Erlang shell allows you to type expressions and execute them by pressing Enter . Every expression typed on the shell must be terminated with a full-stop. Try invoking the function greet of the hello module. The function greet accepts one argument, the name of the person to greet, specified as a string enclosed within double quotes. 1 > hello : greet ( \"Duncan\" ). Hello there , Duncan ! ok 2 > 5. Quit the Erlang shell by typing q(). Function signatures In Erlang (and Elixir), functions are uniquely identified via the triple mod : fun / arity , where mod is the module name, fun , the name of the function contained in the module, and arity , the number of arguments that the function accepts. This reference format is commonly known as MFA . For example, our greet function inside the module hello can be concisely referred to as hello : greet / 1 .","title":"Hello world"},{"location":"getting-started/quickstart.html#hello-world-the-asynchronous-way","text":"You might have noticed that hello : greet / 1 pauses the Erlang shell momentarily before the greeting is displayed. During this interval, the shell is inoperable and cannot accept user input. Such function calls are called synchronous invocations, since they block the caller until the called function returns, i.e. the body of the called function is executed in its entirety and a value is returned to the caller. Examining the body of greet below makes it clear why the Erlang shell stops responding when the function call is effected. 1 2 3 greet ( Name ) -> timer : sleep ( 5000 ), % Pause for 5 seconds to simulate some work.. io : format ( \"Hello there, ~s ! ~n \" , [ Name ]). Line 1 defines the function greet that accepts Name as parameter, while line 3 prints the greeting on the Erlang shell via call to io : format / 2 . The call timer : sleep ( 5000 ) on line 2 pauses the caller process ( i.e. the Erlang shell, in this case) for 5000 ms before executing the rest of the function body. In Erlang, the function return value is the result of the last expression in the function body; for the case of greet , this value is the atom ok that is returned by io : format / 2 . Synchronous calls Synchronous function calls are useful when one needs to ensure that certain processes execute in some prescribed order with respect to one another, e.g. in lock step. This mode of interaction is common to many standard communication protocols such as HTTP , SMTP , DNS , etc. Unwanted synchrony can be easily avoided by launching functions to execute as independent processes that run concurrently with other processes in the system. To this end, Erlang provides the Built-in Functions spawn / { 1 - 4 } , and their variations. We slightly tweak our hello world example to spawn hello : greet / 1 as a separate process that executes concurrently with the Erlang shell process. 4 5 start_greet ( Name ) when is_list ( Name ) -> spawn ( ? MODULE , greet , [ Name ]). The function hello : start_greet / 1 implements this modification. It uses the BIF spawn / 3 (line 2 ) to launch the hello : greet / 1 function as a process, returning its process ID. The Process ID (also called the PID ) is a triple that uniquely identifies an Erlang process executing on the EVM . Function start_greet makes use of the predefined macro ? MODULE , that gets replaced with the name of the module it appears in when the source code of the hello module is preprocessed by the Erlang compiler. Concretely, the invocation to spawn/3 on line 5 yields the source code spawn ( hello , greet , [ Name ]) prior to compilation. Restart the Erlang shell and invoke hello : start_greet / 1 . 1 > hello : start_greet ( \"Duncan\" ). < 0 . 84 . 0 > Hello there , Duncan ! % Shown after a slight pause. 2 > Observe that now: The return value of start_greet is the PID <0.84.0> instead of the atom ok ; The Erlang shell does not block, but returns immediately; After the predefined sleep time elapses, the greeting is printed to the shell.","title":"Hello world, the asynchronous way"},{"location":"getting-started/quickstart.html#outline-runtime-monitoring","text":"In this quickstart demo, we monitor the execution of our asynchronous hello world example using the outline form of instrumentation. Launch the shell as previous, adding the hello world binaries in ebin to the Erlang code path. The detectEr binaries compiled earlier are also included. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> Compile the sample hello_prop.hml property script to generate the corresponding analyser binary. 1 > hml_eval : compile ( \"props/hello_prop.hml\" , [{ outdir , \"ebin\" }, v ]). This compilation procedure, known as the synthesis , translates sHML specifications written in *.hml script files to their analyser equivalents. For now, it suffices to know that sHML \u2014the logic used by detectEr\u2014expresses properties of the system one wishes to runtime verify. Our analyser Erlang binary generated from the sample property is placed in /detecter/examples/erlang/ebin and automatically loaded for use in the shell code path. 2 > ls ( \"ebin\" ). hello . beam hello_prop . beam ... The analyser hello_prop exposes a single function, mfa_spec / 1 , that accepts the MFArgs triple { Mod , Fun , Args } designating the Erlang process to be analysed. Specifically, Mod , Fun and Args are the components of the function passed as arguments to spawn / 3 . For our hello world example, Mod is the atom hello , Fun is the function name greet , and Args , the singleton argument list containing the name of the person to be greeted. You can test hello_prop : mfa_spec / 1 analyser function by providing the triple { hello , greet , [ \"Duncan\" ]} . 3 > hello_prop : mfa_spec ({ hello , greet ,[ \"Duncan\" ]}). *** [ < 0 . 82 . 0 > ] Instrumenting monitor for MFA pattern '{hello,greet,[\"Duncan\"]}' . *** [ < 0 . 82 . 0 > ] Reached verdict 'no' . Launch the monitored system. 4 > monitor : start_online ({ hello , start_greet ,[ \"Duncan\" ]}, fun hello_prop : mfa_spec / 1 , []). % (1) The function monitor : start_online / 3 accepts three arguments: a MFArgs describing the function that is to be spawned as an Erlang process, the analyser function, and a list of options . Setting MFArgs to { hello , start_greet ,[ \"Duncan\" ]} and the analyser to fun hello_prop : mfa_spec / 1 launches the hello world and analyser processes to execute concurrently. In the simple instance of the analyser hello_prop , monitoring terminates promptly with the verdict no as soon as the system starts executing. This no verdict informs us that our hello world program violated the sHML specification in hello_prop.hml . We next learn how sHML can be used to express useful properties that precisely and unambiguously describe the behaviour we want our systems not to infringe.","title":"Outline runtime monitoring"},{"location":"getting-started/setting-up-detecter.html","text":"Setting up detectEr Downloading detectEr detectEr can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling and testing detectEr examples Tutorial examples erlang Calculator server implementation in Erlang src Erlang module sources props sHML property specifications Makefile Makefile with targets for compiling the example elixir Calculator server implementation in Elixir lib Elixir module sources props sHML property specifications Makefile Makefile with targets for compiling the example python Calculator server implementation in Python using TCP sockets src Python script sources props sHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license Compiling detectEr For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential package which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules as *.beam executables. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr","title":"Setting up detectEr"},{"location":"getting-started/setting-up-detecter.html#setting-up-detecter","text":"","title":"Setting up detectEr"},{"location":"getting-started/setting-up-detecter.html#downloading-detecter","text":"detectEr can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling and testing detectEr examples Tutorial examples erlang Calculator server implementation in Erlang src Erlang module sources props sHML property specifications Makefile Makefile with targets for compiling the example elixir Calculator server implementation in Elixir lib Elixir module sources props sHML property specifications Makefile Makefile with targets for compiling the example python Calculator server implementation in Python using TCP sockets src Python script sources props sHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license","title":"Downloading detectEr"},{"location":"getting-started/setting-up-detecter.html#compiling-detecter","text":"For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential package which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules as *.beam executables. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr","title":"Compiling detectEr"},{"location":"using-detecter/instrumentation.html","text":"Instrumentation Diagram of the system architecture. How the same generated analyzer code is used to instrument the Erlang, Elixir and Python setups. Outline instrumentation","title":"Instrumentation"},{"location":"using-detecter/instrumentation.html#instrumentation","text":"Diagram of the system architecture. How the same generated analyzer code is used to instrument the Erlang, Elixir and Python setups.","title":"Instrumentation"},{"location":"using-detecter/instrumentation.html#outline-instrumentation","text":"","title":"Outline instrumentation"},{"location":"using-detecter/system-properties.html","text":"System Properties Explain each property Show how to synthesise one and discuss the generated code. The property of request count, but instead of the exit event use the init event of the process. Specify a simple property and explain the synthesised code, giving an example of how the events are consumed and processed. Probably it will be the first property in the paper or else, the second one for which we have the automaton and we can show the corresponding code generated in Erlang.","title":"System Properties"},{"location":"using-detecter/system-properties.html#system-properties","text":"","title":"System Properties"},{"location":"using-detecter/system-properties.html#explain-each-property","text":"","title":"Explain each property"},{"location":"using-detecter/system-properties.html#show-how-to-synthesise-one-and-discuss-the-generated-code","text":"The property of request count, but instead of the exit event use the init event of the process. Specify a simple property and explain the synthesised code, giving an example of how the events are consumed and processed. Probably it will be the first property in the paper or else, the second one for which we have the automaton and we can show the corresponding code generated in Erlang.","title":"Show how to synthesise one and discuss the generated code."},{"location":"using-detecter/the-specification-logic.html","text":"The Specification Logic Start by saying the the contents of the hello_world prop are simple ff that cannot be satisfied by any ssytem. Discuss the four constructs of the logic. EG: Simple necessities. Discuss the constraint language and insert a table of all the operators it supports. Discuss the properties in the paper and explain how these are expressed in the logic SHML.","title":"The Specification Logic"},{"location":"using-detecter/the-specification-logic.html#the-specification-logic","text":"Start by saying the the contents of the hello_world prop are simple ff that cannot be satisfied by any ssytem. Discuss the four constructs of the logic. EG: Simple necessities. Discuss the constraint language and insert a table of all the operators it supports. Discuss the properties in the paper and explain how these are expressed in the logic SHML.","title":"The Specification Logic"}]}