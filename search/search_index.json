{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the detectEr tutorial! \u00b6 What is detectEr? \u00b6 detectEr is a runtime verification tool for asynchronous component systems that run on the Erlang Virtual Machine. It also supports monitoring systems that can execute outside of the EVM, so long as these can produce traces that are formatted in a way that is parsable by detectEr. The tool itself is developed in Erlang, and is the product of five years of theoretical and practical development. How it works \u00b6 There are two ingredients required for detectEr to work. The first one is a script file containing specifications of the properties one would like to monitor. Properties in detectEr are expressed in sHML\u2014a runtime monitorable syntactic subset of the more expressive modal \u03bc-calculus\u2014used to specify safety properties . detectEr compiles these specifications down to executable Erlang code that analyses program events to reach monitoring verdicts that correspond to property violations. The second ingredient detectEr requires is the program to be monitored, also called the program under scrutiny. detectEr instruments the program with the aforementioned analyser code. detectEr supports three instrumentation methods: inline, outline and offline. In inline instrumentation, detectEr statically instruments the program under scrutiny by weaving the executable analyser instructions via code injection. The ensuing runtime analysis then takes place as the weaved program components execute. Outline monitors enables detectEr to take a dynamic instrumentation approach that treats the system as a black box. It leverages the tracing infrastructure provided by the EVM to gather trace events that are reported to independent component analysers. detectEr also extends outline instrumentation to the offline case, where events read from a trace dump are replayed to emulate the interaction between concurrent system components. This tutorial overviews the inner workings of detectEr. It showcases the inline, outline, and offline monitoring functionality of the tool, demonstrating how each can be employed to monitor programs that are subject to specific deployment and runtime constraints. We highly encourage you to consult the paper that accompanies this tutorial, since it complements many of the concepts covered here. Interested readers are also referred to the list of publications that follows. Publications \u00b6 List of publications. Help us \u00b6 Please help us improve this tutorial and the tool detectEr! We would appreciate if any typos or bugs found are reported on the issues page on GitHub. Our group \u00b6 detectEr is part of the TheoFoMon and MoVeMnt projects funded by the Icelandic Research Fund . Duncan Paul Attard\u2014the principal developer of the detectEr\u2014is a researcher with the ICE-TCS research group at Reykjav\u00edk University. He has worked as a software developer in the Telecoms and Online payment industry for seven years prior to joining the academia. The research group consists of these members who actively contribute towards the theoretical and practical developments of detectEr: Luca Aceto Antonis Achilleos Duncan Paul Attard Adrian Francalanza Karoliina Lehtinen Anna Ing\u00f3lfsd\u00f3ttir We would like to thank X, Y and Z for their comments and feedback.","title":"Home"},{"location":"index.html#welcome-to-the-detecter-tutorial","text":"","title":"Welcome to the detectEr tutorial!"},{"location":"index.html#what-is-detecter","text":"detectEr is a runtime verification tool for asynchronous component systems that run on the Erlang Virtual Machine. It also supports monitoring systems that can execute outside of the EVM, so long as these can produce traces that are formatted in a way that is parsable by detectEr. The tool itself is developed in Erlang, and is the product of five years of theoretical and practical development.","title":"What is detectEr?"},{"location":"index.html#how-it-works","text":"There are two ingredients required for detectEr to work. The first one is a script file containing specifications of the properties one would like to monitor. Properties in detectEr are expressed in sHML\u2014a runtime monitorable syntactic subset of the more expressive modal \u03bc-calculus\u2014used to specify safety properties . detectEr compiles these specifications down to executable Erlang code that analyses program events to reach monitoring verdicts that correspond to property violations. The second ingredient detectEr requires is the program to be monitored, also called the program under scrutiny. detectEr instruments the program with the aforementioned analyser code. detectEr supports three instrumentation methods: inline, outline and offline. In inline instrumentation, detectEr statically instruments the program under scrutiny by weaving the executable analyser instructions via code injection. The ensuing runtime analysis then takes place as the weaved program components execute. Outline monitors enables detectEr to take a dynamic instrumentation approach that treats the system as a black box. It leverages the tracing infrastructure provided by the EVM to gather trace events that are reported to independent component analysers. detectEr also extends outline instrumentation to the offline case, where events read from a trace dump are replayed to emulate the interaction between concurrent system components. This tutorial overviews the inner workings of detectEr. It showcases the inline, outline, and offline monitoring functionality of the tool, demonstrating how each can be employed to monitor programs that are subject to specific deployment and runtime constraints. We highly encourage you to consult the paper that accompanies this tutorial, since it complements many of the concepts covered here. Interested readers are also referred to the list of publications that follows.","title":"How it works"},{"location":"index.html#publications","text":"List of publications.","title":"Publications"},{"location":"index.html#help-us","text":"Please help us improve this tutorial and the tool detectEr! We would appreciate if any typos or bugs found are reported on the issues page on GitHub.","title":"Help us"},{"location":"index.html#our-group","text":"detectEr is part of the TheoFoMon and MoVeMnt projects funded by the Icelandic Research Fund . Duncan Paul Attard\u2014the principal developer of the detectEr\u2014is a researcher with the ICE-TCS research group at Reykjav\u00edk University. He has worked as a software developer in the Telecoms and Online payment industry for seven years prior to joining the academia. The research group consists of these members who actively contribute towards the theoretical and practical developments of detectEr: Luca Aceto Antonis Achilleos Duncan Paul Attard Adrian Francalanza Karoliina Lehtinen Anna Ing\u00f3lfsd\u00f3ttir We would like to thank X, Y and Z for their comments and feedback.","title":"Our group"},{"location":"about.html","text":"Turba falsi florem \u00b6 Labentibus corpore nostra \u00b6 Lorem markdownum amplexa rector ora facies lumina sit lurida rursusque terruerat caelebs, diem. Contigit tortoque terebrata flore! daemon_soft_syn = e; overclocking = favicon; if (2 == windows(device, gifServer)) { primary *= botnetT; uncIntegrated(2 + ajax_trim_multiplatform, 664619 - internet_gigabyte_system, sampling_metal_copy); kindle = cronServerPpi; } boot_modem(1, onlineUtility, media - virtualization_trackball - macByteClip); Ab sonus: obruta nimium loco, bis nascendi nautae, solus cur ille turbamque damnatura turba madefactaque nescit Lacedaemoniumque . Ratibus iugulaberis, vetus ulla ubicumque opposui medicamina addita solacia iniusti amplexuque interque, admonitu nunc extendi sol. Nomina parentes potentum conplectitur socio, et dives adice et subit patriaeque crederet. Laesi saecula, dextrae; carpit dolos suspiria probro pendere simul hospita Gorgoneum. Accipe timeri nupsi fuit nostros quid memorem pellite metuunt: Harpalos positis plectrumque somno qui, ter falsa diversa motaque. Cum cum hic fugientibus vaccae de noluit sulphura cantu utque inmensi scopulum , vestra. Undis quotiens veteris nostro iube blanditiis nihil huc latus, igne inpune voluit, abiit, est Acmon viri. Exemplo capiebant o vocabula iusta; incubuitque interius ripas. Genitore sumptaque haud domos recens, pietas ille Zanclen secum; ferox ilice demittere cortice? Glomerari licet io protinus colubris vires egissem \u00b6 Margine de prisca fulvis miserae in illa claroque. Apolline auras ramum fitque quoque artifices oblivia nigraque freta croceum fauce et feres: nec pyra nec vertice: vincloque. Emittere dixit. Ut populis negarunt occuluit simili ne coepit Dianae quinquennia erat scrobe speciosam. Genitor qui terra mutasse nigro ! Glaebae stetit ab a arsit ignibus digna ulcisci repressit: opem arma petis, timendi hos omni et arma puerosque. Faciem conpleat mediis, Capitolia videndo ab aurumque, clamant et mihi bubo praebetis pater viscera deus. Sed pugman, nihil laudatve cervice videri. Alas oris Thetis est superis a picto nulla gente solebat a ossibus quoque! Et suis, quae Cyllenide imoque at, quisquis nulli, repetitum. Silvas est absens negata faciat iamque putant; re et, qua dixit. Excutis adsiduae Lyncides. Suis Sithon vocat pennis lupo fallitis potuit inrorant laetoque. Hic raptores possunt fatebor cornum usa.","title":"Turba falsi florem"},{"location":"about.html#turba-falsi-florem","text":"","title":"Turba falsi florem"},{"location":"about.html#labentibus-corpore-nostra","text":"Lorem markdownum amplexa rector ora facies lumina sit lurida rursusque terruerat caelebs, diem. Contigit tortoque terebrata flore! daemon_soft_syn = e; overclocking = favicon; if (2 == windows(device, gifServer)) { primary *= botnetT; uncIntegrated(2 + ajax_trim_multiplatform, 664619 - internet_gigabyte_system, sampling_metal_copy); kindle = cronServerPpi; } boot_modem(1, onlineUtility, media - virtualization_trackball - macByteClip); Ab sonus: obruta nimium loco, bis nascendi nautae, solus cur ille turbamque damnatura turba madefactaque nescit Lacedaemoniumque . Ratibus iugulaberis, vetus ulla ubicumque opposui medicamina addita solacia iniusti amplexuque interque, admonitu nunc extendi sol. Nomina parentes potentum conplectitur socio, et dives adice et subit patriaeque crederet. Laesi saecula, dextrae; carpit dolos suspiria probro pendere simul hospita Gorgoneum. Accipe timeri nupsi fuit nostros quid memorem pellite metuunt: Harpalos positis plectrumque somno qui, ter falsa diversa motaque. Cum cum hic fugientibus vaccae de noluit sulphura cantu utque inmensi scopulum , vestra. Undis quotiens veteris nostro iube blanditiis nihil huc latus, igne inpune voluit, abiit, est Acmon viri. Exemplo capiebant o vocabula iusta; incubuitque interius ripas. Genitore sumptaque haud domos recens, pietas ille Zanclen secum; ferox ilice demittere cortice?","title":"Labentibus corpore nostra"},{"location":"about.html#glomerari-licet-io-protinus-colubris-vires-egissem","text":"Margine de prisca fulvis miserae in illa claroque. Apolline auras ramum fitque quoque artifices oblivia nigraque freta croceum fauce et feres: nec pyra nec vertice: vincloque. Emittere dixit. Ut populis negarunt occuluit simili ne coepit Dianae quinquennia erat scrobe speciosam. Genitor qui terra mutasse nigro ! Glaebae stetit ab a arsit ignibus digna ulcisci repressit: opem arma petis, timendi hos omni et arma puerosque. Faciem conpleat mediis, Capitolia videndo ab aurumque, clamant et mihi bubo praebetis pater viscera deus. Sed pugman, nihil laudatve cervice videri. Alas oris Thetis est superis a picto nulla gente solebat a ossibus quoque! Et suis, quae Cyllenide imoque at, quisquis nulli, repetitum. Silvas est absens negata faciat iamque putant; re et, qua dixit. Excutis adsiduae Lyncides. Suis Sithon vocat pennis lupo fallitis potuit inrorant laetoque. Hic raptores possunt fatebor cornum usa.","title":"Glomerari licet io protinus colubris vires egissem"},{"location":"erlang.html","text":"This is a test \u00b6 with calc_server : loop (_) monitor and ([_ Launcher <- _ Server , calc_server : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B ] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). with 'Elixir.Demo.CalcServer' : loop (_) monitor and ([_ Launcher <- _ Server , 'Elixir.Demo.CalcServer' : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B and is_integer ( A )] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). 1 2 3 4 5 6 7 fun ( Var ) -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end The range () function is used to generate a sequence of numbers. Ctrl + Alt + Del Ctrl + V + Tab + Enter + Cmd Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Hello Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Unordered List Example : * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci The HTML specification is maintained by the W3C . Duncan \\[ \\operatorname{ker} f=\\{g\\in {\\color{sepia}{G}}:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"This is a test"},{"location":"erlang.html#this-is-a-test","text":"with calc_server : loop (_) monitor and ([_ Launcher <- _ Server , calc_server : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B ] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). with 'Elixir.Demo.CalcServer' : loop (_) monitor and ([_ Launcher <- _ Server , 'Elixir.Demo.CalcServer' : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B and is_integer ( A )] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). 1 2 3 4 5 6 7 fun ( Var ) -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end The range () function is used to generate a sequence of numbers. Ctrl + Alt + Del Ctrl + V + Tab + Enter + Cmd Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Hello Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Unordered List Example : * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci The HTML specification is maintained by the W3C . Duncan \\[ \\operatorname{ker} f=\\{g\\in {\\color{sepia}{G}}:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"This is a test"},{"location":"getting-started/preparation.html","text":"Preparation \u00b6 Prerequisites \u00b6 This tutorial assumes that users are running Ubuntu/Debian, macOS or Windows 10. Windows 10 users may either install the Windows Subsystem for Linux and follow the instructions given below for Ubuntu/Debian , or alternatively, configure Chocolatey and install the software packages mentioned via choco install . However, our instructions will not detail how detectEr is installed and used on Windows systems. Please install the software package management system available for your particular operating system before proceeding with the rest of the guide. Operating System Package Manager Installation Ubuntu/Debian APT Not required, comes pre-bundled macOS Homebrew Follow the Homebrew guide for installation Windows 10 Chocolatey Follow the Chocolatey guide for installation Installing Erlang \u00b6 Erlang can be installed on multiple platforms by compiling it from source or downloading one of the pre-compiled distributions hosted on erlang-solutions.com . We however follow the simpler route and install Erlang using the package managers mentioned above. Ubuntu/Debian On Ubuntu and Debian, Erlang can be installed using APT . Add the Erlang Solutions repository: wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb sudo dpkg -i erlang-solutions_2.0_all.deb Refresh the package manager repository cache: sudo apt update . Install the entire Erlang/ OTP suite only: sudo apt install erlang . macOS macOS users can install the entire Erlang/ OTP suite using Homebrew by running: brew install erlang . Windows 10 Windows 10 users not using WSL can install the entire Erlang/ OTP suite using Chocolatey by running: choco install erlang . Others Refer to the Erlang Solutions guide for installing Erlang/ OTP on other operating systems. Quick check Confirm that Erlang/ OTP distribution has been successfully installed and that the system PATH variable is properly configured by typing erl --version . Installing Elixir \u00b6 Elixir runs on the Erlang virtual machine and uses the same OTP libraries. We already installed the Erlang ecosystem, and need only install the Elixir language libraries. Ubuntu/Debian On Ubuntu and Debian, Elixir can be installed via APT using: sudo apt-get install elixir . macOS macOS users can install Elixir using Homebrew by running: brew install elixir . Windows 10 Windows 10 users not using WSL can install Elixir using Chocolatey by running: choco install elixir . Others Refer to the Elixir Lang guide for installing Elixir on other operating systems. Quick check Confirm that Elixir has been successfully installed and that the system PATH variable is properly configured by typing elixir --version . Installing Python \u00b6 We also make use of Python 3, that can be installed as explained below. Ubuntu/Debian Most distributions of Ubuntu and Debian come with Python pre-installed. Check the version of Python available on your operating system by executing python --version . If the reported version is older than 3.7.x or Python is not installed, follow these steps. Refresh the package manager repository cache (if not already done): sudo apt update . Install Python 3: sudo apt install python3.9 . Install the Python package manager PIP : sudo apt install python3-pip . Also install the core development support tools: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev . macOS macOS comes pre-installed with Python 2.7, which is not the version we use in this tutorial. Install Python 3 via Homebrew by typing: brew install python3 . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Windows 10 Windows 10 users not using WSL can install Python 3 via Chocolatey by typing: choco install python . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Others Refer to the Real Python guide for installing Python 3 on other operating systems. Quick check Confirm that Python 3 has been successfully installed and that the system PATH variable is properly configured by typing python3 --version . Also check that PIP for Python 3 has been installed, pip3 --version . Installing the virtual environment management tool \u00b6 Virtualenv is a tool used to create isolated Python environments. The environment it creates has its own installation directory, and does not share libraries with other Virtualenv environments. Virtualenv can be installed via PIP : pip3 install virtualenv . Configuring Visual Studio Code \u00b6 Any plain text editor can be used, but for this tutorial we opt for Visual Studio Code that can be downloaded from https://code.visualstudio.com . It can also be installed using the respective operating system package manager. Ubuntu/Debian On Ubuntu and Debian, VS Code can be installed using APT . Install APT transport for downloading packages via HTTPS: sudo apt install apt-transport-https to check Import the Microsoft GPG key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository by typing: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/code stable main\" Refresh the package manager repository cache: sudo apt update . Install VS Code: sudo apt install code . macOS macOS users can install VS Code using Homebrew by running: brew install --cask visual-studio-code . Windows 10 Windows 10 users not using WSL can install VS Code using Chocolatey by running: choco install vscode . Others Refer to the Visual Studio Code guide for installing it on other operating systems. Adding extensions \u00b6 To enable syntax highlighting and language support for the languages used in this tutorial, VS Code can be configured with these extensions. Erlang . Elixir . Python . sHML syntax highlighting? Versions These distribution versions are used in this tutorial. Your installed versions need not exactly match, but we document these in case of any problems you might face when working through the tutorial later on. Name Version Erlang/ OTP 23.3.2 Elixir 1.11.4 Python 3.9.4 PIP 21.0.1 VS Code 1.56.0 Now that your system is set up, we can proceed to download and compile detectEr.","title":"Preparation"},{"location":"getting-started/preparation.html#preparation","text":"","title":"Preparation"},{"location":"getting-started/preparation.html#prerequisites","text":"This tutorial assumes that users are running Ubuntu/Debian, macOS or Windows 10. Windows 10 users may either install the Windows Subsystem for Linux and follow the instructions given below for Ubuntu/Debian , or alternatively, configure Chocolatey and install the software packages mentioned via choco install . However, our instructions will not detail how detectEr is installed and used on Windows systems. Please install the software package management system available for your particular operating system before proceeding with the rest of the guide. Operating System Package Manager Installation Ubuntu/Debian APT Not required, comes pre-bundled macOS Homebrew Follow the Homebrew guide for installation Windows 10 Chocolatey Follow the Chocolatey guide for installation","title":"Prerequisites"},{"location":"getting-started/preparation.html#installing-erlang","text":"Erlang can be installed on multiple platforms by compiling it from source or downloading one of the pre-compiled distributions hosted on erlang-solutions.com . We however follow the simpler route and install Erlang using the package managers mentioned above. Ubuntu/Debian On Ubuntu and Debian, Erlang can be installed using APT . Add the Erlang Solutions repository: wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb sudo dpkg -i erlang-solutions_2.0_all.deb Refresh the package manager repository cache: sudo apt update . Install the entire Erlang/ OTP suite only: sudo apt install erlang . macOS macOS users can install the entire Erlang/ OTP suite using Homebrew by running: brew install erlang . Windows 10 Windows 10 users not using WSL can install the entire Erlang/ OTP suite using Chocolatey by running: choco install erlang . Others Refer to the Erlang Solutions guide for installing Erlang/ OTP on other operating systems. Quick check Confirm that Erlang/ OTP distribution has been successfully installed and that the system PATH variable is properly configured by typing erl --version .","title":"Installing Erlang"},{"location":"getting-started/preparation.html#installing-elixir","text":"Elixir runs on the Erlang virtual machine and uses the same OTP libraries. We already installed the Erlang ecosystem, and need only install the Elixir language libraries. Ubuntu/Debian On Ubuntu and Debian, Elixir can be installed via APT using: sudo apt-get install elixir . macOS macOS users can install Elixir using Homebrew by running: brew install elixir . Windows 10 Windows 10 users not using WSL can install Elixir using Chocolatey by running: choco install elixir . Others Refer to the Elixir Lang guide for installing Elixir on other operating systems. Quick check Confirm that Elixir has been successfully installed and that the system PATH variable is properly configured by typing elixir --version .","title":"Installing Elixir"},{"location":"getting-started/preparation.html#installing-python","text":"We also make use of Python 3, that can be installed as explained below. Ubuntu/Debian Most distributions of Ubuntu and Debian come with Python pre-installed. Check the version of Python available on your operating system by executing python --version . If the reported version is older than 3.7.x or Python is not installed, follow these steps. Refresh the package manager repository cache (if not already done): sudo apt update . Install Python 3: sudo apt install python3.9 . Install the Python package manager PIP : sudo apt install python3-pip . Also install the core development support tools: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev . macOS macOS comes pre-installed with Python 2.7, which is not the version we use in this tutorial. Install Python 3 via Homebrew by typing: brew install python3 . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Windows 10 Windows 10 users not using WSL can install Python 3 via Chocolatey by typing: choco install python . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Others Refer to the Real Python guide for installing Python 3 on other operating systems. Quick check Confirm that Python 3 has been successfully installed and that the system PATH variable is properly configured by typing python3 --version . Also check that PIP for Python 3 has been installed, pip3 --version .","title":"Installing Python"},{"location":"getting-started/preparation.html#installing-the-virtual-environment-management-tool","text":"Virtualenv is a tool used to create isolated Python environments. The environment it creates has its own installation directory, and does not share libraries with other Virtualenv environments. Virtualenv can be installed via PIP : pip3 install virtualenv .","title":"Installing the virtual environment management tool"},{"location":"getting-started/preparation.html#configuring-visual-studio-code","text":"Any plain text editor can be used, but for this tutorial we opt for Visual Studio Code that can be downloaded from https://code.visualstudio.com . It can also be installed using the respective operating system package manager. Ubuntu/Debian On Ubuntu and Debian, VS Code can be installed using APT . Install APT transport for downloading packages via HTTPS: sudo apt install apt-transport-https to check Import the Microsoft GPG key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository by typing: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/code stable main\" Refresh the package manager repository cache: sudo apt update . Install VS Code: sudo apt install code . macOS macOS users can install VS Code using Homebrew by running: brew install --cask visual-studio-code . Windows 10 Windows 10 users not using WSL can install VS Code using Chocolatey by running: choco install vscode . Others Refer to the Visual Studio Code guide for installing it on other operating systems.","title":"Configuring Visual Studio Code"},{"location":"getting-started/preparation.html#adding-extensions","text":"To enable syntax highlighting and language support for the languages used in this tutorial, VS Code can be configured with these extensions. Erlang . Elixir . Python . sHML syntax highlighting? Versions These distribution versions are used in this tutorial. Your installed versions need not exactly match, but we document these in case of any problems you might face when working through the tutorial later on. Name Version Erlang/ OTP 23.3.2 Elixir 1.11.4 Python 3.9.4 PIP 21.0.1 VS Code 1.56.0 Now that your system is set up, we can proceed to download and compile detectEr.","title":"Adding extensions"},{"location":"getting-started/quickstart.html","text":"Quickstart \u00b6 Launching detectEr from the shell \u00b6 The detecter/ebin directory created previously needs to be included in the Erlang runtime path to preload all the binaries required to be able to use detectEr. This is done by using the -pa switch when launching the Erlang shell. [duncan@local]:$ erl -pa /path/to/detecter/ebin Once loaded, detectEr can be used to monitor systems that execute on the Erlang Virtual Machine. It also supports the monitoring of systems that run outside of the EVM , provided that these record their logs in files following a predetermined formatting that enables detectEr to extract runtime information. This topic is covered in more depth in the Instrumentation section. For now, we establish the workflow required to use detectEr by way of the traditional \u2018hello world\u2019 example. Hello world \u00b6 Before using detectEr, you should get an intuitive grasp of what monitoring is, and the steps one needs to follow to initialise and start the monitoring process. If this is your first time using Erlang, the following wil help you get acquainted with the Erlang shell. Launch a new terminal emulator window ( e.g. Terminal on Ubuntu or macOS), navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. BEAM files are (fairly) portable binaries consisting of bytecode that is interpreted by the EVM , similar to how Java operates. [duncan@local]:/detecter/examples/erlang$ make rm -f ebin/*.beam ebin/*.E ebin/*.tmp erl_crash.dump ebin/*.app ... [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 7 duncan duncan 224 May 17 17:16 ebin drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src 3. Launch the Erlang shell erl . We add the binaries of the ebin directory to the Erlang code path via the -pa flag to load and make them accessible from the shell. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> 4. The Erlang shell allows you to type expressions and execute them by pressing Enter . Every expression typed on the shell must be terminated with a full-stop. Try invoking the function greet of the hello module. The function greet accepts one argument, the name of the person to greet, specified as a string enclosed within double quotes. 1 > hello : greet ( \"Duncan\" ). Hello there , Duncan ! ok 2 > 5. Quit the Erlang shell by typing q(). Function signatures In Erlang (and Elixir), functions are uniquely identified via the triple mod : fun / arity , where mod is the module name, fun , the name of the function contained in the module, and arity , the number of arguments that the function accepts. This reference format is commonly known as MFA . For example, our greet function inside the module hello can be concisely referred to as hello : greet / 1 . We refer to functions in the same module simply as fun / arity . Hello world, the asynchronous way \u00b6 You might have noticed that hello : greet / 1 pauses the Erlang shell momentarily before the greeting is displayed. During this interval, the shell is inoperable and cannot accept user input. Such function calls are called synchronous invocations, since they block the caller until the called function returns, i.e. the body of the called function is executed in its entirety and a value is returned to the caller. Examining the body of greet below makes it clear why the Erlang shell stops responding when the function call is effected. 1 2 3 greet ( Name ) -> timer : sleep ( 5000 ), % Pause for 5 seconds to simulate some work.. io : format ( \"Hello there, ~s ! ~n \" , [ Name ]). Line 1 defines the function greet that accepts Name as parameter, while line 3 prints the greeting on the Erlang shell via call to io : format / 2 . The call timer : sleep ( 5000 ) on line 2 pauses the caller process ( i.e. the Erlang shell, in this case) for 5000 ms before executing the rest of the function body. In Erlang, the function return value is the result of the last expression in the function body; for the case of greet , this value is the atom ok that is returned by io : format / 2 . Synchronous calls Synchronous function calls are useful when one needs to ensure that certain processes execute in some prescribed order with respect to one another, e.g. in lock step. This mode of interaction is common to many standard communication protocols such as HTTP , SMTP , DNS , etc. Unwanted synchrony can be easily avoided by launching functions to execute as independent processes that run concurrently with other processes in the system. To this end, Erlang provides the Built-in Functions spawn / { 1 - 4 } , and their variations . We slightly tweak our hello world example to spawn hello : greet / 1 as a separate process that executes concurrently with the Erlang shell process. 4 5 start_greet ( Name ) when is_list ( Name ) -> spawn ( ? MODULE , greet , [ Name ]). The function start_greet / 1 implements this modification. It uses the BIF spawn / 3 (line 5 ) to launch hello : greet / 1 as a process, returning the new process ID. Process IDs ( PIDs for short) are triples of the form < A . B . C > that uniquely identify Erlang processes executing on the EVM . spawn / 3 is parametrised by the module name, the name of the function to spawn, and the list of arguments accepted by the function. Function start_greet / 1 makes use of the predefined macro ? MODULE , that gets replaced with the name of the module it appears in when the source code of the hello module is preprocessed by the Erlang compiler. Concretely, the invocation to spawn/3 on line 5 yields the source code spawn ( hello , greet , [ Name ]) prior to compilation. Restart the Erlang shell and invoke hello : start_greet / 1 . 1 > hello : start_greet ( \"Duncan\" ). < 0 . 97 . 0 > Hello there , Duncan ! % Shown after a slight pause. 2 > Observe that now: The return value of start_greet is the PID of the spawned process < 0 . 97 . 0 > instead of the atom ok ; The Erlang shell does not block, but returns immediately; After the predefined sleep time elapses, the greeting is printed to the shell. Outline runtime monitoring \u00b6 In this quickstart demo, we monitor the execution of our asynchronous hello world example using the outline form of instrumentation. Launch the shell as previous, adding the hello world binaries in ebin to the Erlang code path. The detectEr binaries compiled earlier are also included. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> Compile the sample prop_hello.hml property script to generate the corresponding analyser binary. 1 > hml_eval : compile ( \"props/prop_hello.hml\" , [{ outdir , \"ebin\" }, v ]). This compilation procedure, known as the synthesis , translates sHML specifications written in *.hml script files to their analyser equivalents. For now, it suffices to know that sHML \u2014the logic used by detectEr\u2014expresses properties of the system one wishes to runtime verify. Our analyser Erlang binary generated from the sample property is placed in /detecter/examples/erlang/ebin and automatically loaded for use in the shell code path. 2 > ls ( \"ebin\" ). hello . beam prop_hello . beam ... The analyser prop_hello exposes a single function, mfa_spec / 1 , that accepts the MFArgs triple { Mod , Fun , Args } designating the Erlang process to be analysed. Specifically, Mod , Fun and Args are the components of the function passed as arguments to spawn / 3 . For our hello world example, Mod is the atom hello , Fun is the function name greet , and Args , the singleton argument list containing the name of the person to be greeted. You can test prop_hello : mfa_spec / 1 analyser function by providing the triple { hello , greet , [ \"Duncan\" ]} . 3 > prop_hello : mfa_spec ({ hello , greet , [ \"Duncan\" ]}). *** [ < 0 . 82 . 0 > ] Instrumenting monitor for MFA pattern '{hello, greet, [\"Duncan\"]}' . *** [ < 0 . 82 . 0 > ] Reached verdict 'no' . Launch the monitored system. 4 > monitor : start_online ({ hello , start_greet , [ \"Duncan\" ]}, fun prop_hello : mfa_spec / 1 , []). The function monitor : start_online / 3 accepts three arguments: a MFArgs describing the function that is to be spawned as an Erlang process, the analyser function, and a list of options . Setting MFArgs to { hello , start_greet ,[ \"Duncan\" ]} and the analyser to fun prop_hello : mfa_spec / 1 launches the hello world and analyser processes to execute concurrently. In this introductory example, the analyser prop_hello promptly terminates with the verdict no as soon as our hello world program starts executing. The no verdict informs us that a program has violated the specification of prop_hello.hml . We next look at a typical concurrent program where processes interact, and study what kind of useful properties one might want such systems to observe.","title":"Quickstart"},{"location":"getting-started/quickstart.html#quickstart","text":"","title":"Quickstart"},{"location":"getting-started/quickstart.html#launching-detecter-from-the-shell","text":"The detecter/ebin directory created previously needs to be included in the Erlang runtime path to preload all the binaries required to be able to use detectEr. This is done by using the -pa switch when launching the Erlang shell. [duncan@local]:$ erl -pa /path/to/detecter/ebin Once loaded, detectEr can be used to monitor systems that execute on the Erlang Virtual Machine. It also supports the monitoring of systems that run outside of the EVM , provided that these record their logs in files following a predetermined formatting that enables detectEr to extract runtime information. This topic is covered in more depth in the Instrumentation section. For now, we establish the workflow required to use detectEr by way of the traditional \u2018hello world\u2019 example.","title":"Launching detectEr from the shell"},{"location":"getting-started/quickstart.html#hello-world","text":"Before using detectEr, you should get an intuitive grasp of what monitoring is, and the steps one needs to follow to initialise and start the monitoring process. If this is your first time using Erlang, the following wil help you get acquainted with the Erlang shell. Launch a new terminal emulator window ( e.g. Terminal on Ubuntu or macOS), navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. BEAM files are (fairly) portable binaries consisting of bytecode that is interpreted by the EVM , similar to how Java operates. [duncan@local]:/detecter/examples/erlang$ make rm -f ebin/*.beam ebin/*.E ebin/*.tmp erl_crash.dump ebin/*.app ... [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 7 duncan duncan 224 May 17 17:16 ebin drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src 3. Launch the Erlang shell erl . We add the binaries of the ebin directory to the Erlang code path via the -pa flag to load and make them accessible from the shell. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> 4. The Erlang shell allows you to type expressions and execute them by pressing Enter . Every expression typed on the shell must be terminated with a full-stop. Try invoking the function greet of the hello module. The function greet accepts one argument, the name of the person to greet, specified as a string enclosed within double quotes. 1 > hello : greet ( \"Duncan\" ). Hello there , Duncan ! ok 2 > 5. Quit the Erlang shell by typing q(). Function signatures In Erlang (and Elixir), functions are uniquely identified via the triple mod : fun / arity , where mod is the module name, fun , the name of the function contained in the module, and arity , the number of arguments that the function accepts. This reference format is commonly known as MFA . For example, our greet function inside the module hello can be concisely referred to as hello : greet / 1 . We refer to functions in the same module simply as fun / arity .","title":"Hello world"},{"location":"getting-started/quickstart.html#hello-world-the-asynchronous-way","text":"You might have noticed that hello : greet / 1 pauses the Erlang shell momentarily before the greeting is displayed. During this interval, the shell is inoperable and cannot accept user input. Such function calls are called synchronous invocations, since they block the caller until the called function returns, i.e. the body of the called function is executed in its entirety and a value is returned to the caller. Examining the body of greet below makes it clear why the Erlang shell stops responding when the function call is effected. 1 2 3 greet ( Name ) -> timer : sleep ( 5000 ), % Pause for 5 seconds to simulate some work.. io : format ( \"Hello there, ~s ! ~n \" , [ Name ]). Line 1 defines the function greet that accepts Name as parameter, while line 3 prints the greeting on the Erlang shell via call to io : format / 2 . The call timer : sleep ( 5000 ) on line 2 pauses the caller process ( i.e. the Erlang shell, in this case) for 5000 ms before executing the rest of the function body. In Erlang, the function return value is the result of the last expression in the function body; for the case of greet , this value is the atom ok that is returned by io : format / 2 . Synchronous calls Synchronous function calls are useful when one needs to ensure that certain processes execute in some prescribed order with respect to one another, e.g. in lock step. This mode of interaction is common to many standard communication protocols such as HTTP , SMTP , DNS , etc. Unwanted synchrony can be easily avoided by launching functions to execute as independent processes that run concurrently with other processes in the system. To this end, Erlang provides the Built-in Functions spawn / { 1 - 4 } , and their variations . We slightly tweak our hello world example to spawn hello : greet / 1 as a separate process that executes concurrently with the Erlang shell process. 4 5 start_greet ( Name ) when is_list ( Name ) -> spawn ( ? MODULE , greet , [ Name ]). The function start_greet / 1 implements this modification. It uses the BIF spawn / 3 (line 5 ) to launch hello : greet / 1 as a process, returning the new process ID. Process IDs ( PIDs for short) are triples of the form < A . B . C > that uniquely identify Erlang processes executing on the EVM . spawn / 3 is parametrised by the module name, the name of the function to spawn, and the list of arguments accepted by the function. Function start_greet / 1 makes use of the predefined macro ? MODULE , that gets replaced with the name of the module it appears in when the source code of the hello module is preprocessed by the Erlang compiler. Concretely, the invocation to spawn/3 on line 5 yields the source code spawn ( hello , greet , [ Name ]) prior to compilation. Restart the Erlang shell and invoke hello : start_greet / 1 . 1 > hello : start_greet ( \"Duncan\" ). < 0 . 97 . 0 > Hello there , Duncan ! % Shown after a slight pause. 2 > Observe that now: The return value of start_greet is the PID of the spawned process < 0 . 97 . 0 > instead of the atom ok ; The Erlang shell does not block, but returns immediately; After the predefined sleep time elapses, the greeting is printed to the shell.","title":"Hello world, the asynchronous way"},{"location":"getting-started/quickstart.html#outline-runtime-monitoring","text":"In this quickstart demo, we monitor the execution of our asynchronous hello world example using the outline form of instrumentation. Launch the shell as previous, adding the hello world binaries in ebin to the Erlang code path. The detectEr binaries compiled earlier are also included. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> Compile the sample prop_hello.hml property script to generate the corresponding analyser binary. 1 > hml_eval : compile ( \"props/prop_hello.hml\" , [{ outdir , \"ebin\" }, v ]). This compilation procedure, known as the synthesis , translates sHML specifications written in *.hml script files to their analyser equivalents. For now, it suffices to know that sHML \u2014the logic used by detectEr\u2014expresses properties of the system one wishes to runtime verify. Our analyser Erlang binary generated from the sample property is placed in /detecter/examples/erlang/ebin and automatically loaded for use in the shell code path. 2 > ls ( \"ebin\" ). hello . beam prop_hello . beam ... The analyser prop_hello exposes a single function, mfa_spec / 1 , that accepts the MFArgs triple { Mod , Fun , Args } designating the Erlang process to be analysed. Specifically, Mod , Fun and Args are the components of the function passed as arguments to spawn / 3 . For our hello world example, Mod is the atom hello , Fun is the function name greet , and Args , the singleton argument list containing the name of the person to be greeted. You can test prop_hello : mfa_spec / 1 analyser function by providing the triple { hello , greet , [ \"Duncan\" ]} . 3 > prop_hello : mfa_spec ({ hello , greet , [ \"Duncan\" ]}). *** [ < 0 . 82 . 0 > ] Instrumenting monitor for MFA pattern '{hello, greet, [\"Duncan\"]}' . *** [ < 0 . 82 . 0 > ] Reached verdict 'no' . Launch the monitored system. 4 > monitor : start_online ({ hello , start_greet , [ \"Duncan\" ]}, fun prop_hello : mfa_spec / 1 , []). The function monitor : start_online / 3 accepts three arguments: a MFArgs describing the function that is to be spawned as an Erlang process, the analyser function, and a list of options . Setting MFArgs to { hello , start_greet ,[ \"Duncan\" ]} and the analyser to fun prop_hello : mfa_spec / 1 launches the hello world and analyser processes to execute concurrently. In this introductory example, the analyser prop_hello promptly terminates with the verdict no as soon as our hello world program starts executing. The no verdict informs us that a program has violated the specification of prop_hello.hml . We next look at a typical concurrent program where processes interact, and study what kind of useful properties one might want such systems to observe.","title":"Outline runtime monitoring"},{"location":"getting-started/setting-up-detecter.html","text":"Setting up detectEr \u00b6 Downloading detectEr \u00b6 detectEr can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling and testing detectEr examples Tutorial examples erlang Calculator server implementation in Erlang src Erlang module sources props sHML property specifications Makefile Makefile with targets for compiling the example elixir Calculator server implementation in Elixir lib Elixir module sources props sHML property specifications Makefile Makefile with targets for compiling the example python Calculator server implementation in Python using TCP sockets src Python script sources props sHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license Compiling detectEr \u00b6 For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential package which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules as *.beam executables. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr With detectEr compiled, let us move on to our first \u2018hello world\u2019 example!","title":"Setting up detectEr"},{"location":"getting-started/setting-up-detecter.html#setting-up-detecter","text":"","title":"Setting up detectEr"},{"location":"getting-started/setting-up-detecter.html#downloading-detecter","text":"detectEr can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling and testing detectEr examples Tutorial examples erlang Calculator server implementation in Erlang src Erlang module sources props sHML property specifications Makefile Makefile with targets for compiling the example elixir Calculator server implementation in Elixir lib Elixir module sources props sHML property specifications Makefile Makefile with targets for compiling the example python Calculator server implementation in Python using TCP sockets src Python script sources props sHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license","title":"Downloading detectEr"},{"location":"getting-started/setting-up-detecter.html#compiling-detecter","text":"For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential package which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules as *.beam executables. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr With detectEr compiled, let us move on to our first \u2018hello world\u2019 example!","title":"Compiling detectEr"},{"location":"using-detecter/formalising-properties.html","text":"Formalising Properties \u00b6 Choosing what to analyse \u00b6 detectEr provides the keywords with and monitor to target program processes for a particular sHML specification. The with keyword picks out the signature of the function that is spawned as a process, whereas the monitor keyword defines the property to be runtime analysed. For example, to verify the behaviour of our calculator process against a sHML formula \u03c6 , we write: with calc_server : loop (_) monitor \u03c6 From an instrumentation standpoint, with establishes the set of trace events corresponding to the program process it targets, thus enabling the specification to abstract from the events that are generated by other processes. This helps maintain the size of sHML specifications compact whenever possible. In using with , our formula need not account for superfluous trace events ( e.g. of another calculator process) that tend to make the specification exercise tedious and error-prone. Let us formalise the properties from the Getting Started section; these are specified with respect to the five process events fork , init , exit , send , and recv supported by detectEr. We include our calculator server transition model for reference. @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro);&#xa;@import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt,stp} Srv ? {Clt,stp} Srv:Clt ! {bye,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! {ok,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{A,B}} Srv ? {Clt,{A,B}} Srv:Clt ! {ok,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{A,B}} Srv ? {Clt,{A,B}} Viewer does not support full SVG 1.1 Formalising P 1 \u00b6 (P 1 ) The service request count returned on shutdown is never negative. P 1 is an extension of the property that we have already seen earlier, and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff , that requires the program state \u201cnot to exhibit a send event whose payload consists of { bye , Tot } where Tot is negative.\u201d While in principle, this sHML formula is correct, it does not account for the other program events that our calculator server can exhibit from one of its states. For example, from Q0 , the server exhibits recv events that are ignored by the formula; similarly, from Q2 , the server transitions with a send event to Q1 , but the message payload is not the one we are after. We remedy this by adding clauses that handle these possibilities. 1 2 3 4 5 6 7 8 9 10 11 with calc_server : loop (_) monitor and ([ Lnc <- Srv , calc_server : loop ( Args )] max ( X . and ( [ Srv ? Clt ] X , [ Srv : Clt ! { bye , Tot } when Tot < 0 ] ff , [ Srv : Clt ! { Ack , Ans } when Ack =:= ok orelse ( Ack =:= bye andalso Ans >= 0 )] X ) ). Using with .. monitor , we designate the spawned calculator server loop function calc_server : loop / 1 as the process to be analysed against the formalisation of property P 1 (lines 1 - 3 ). Our formalisation of P 1 consists of two conjuncted necessities , i.e. and (...) . The first conjuncted necessity on line 4 handles the init event exhibited by every process upon initialisation (we remark that init was elided in the transition model of our calculator server to simplify our discussion, but we need to account for it!). The second nested and (...) on line 6 includes the additional necessities that cover the other possible events produced by the transition system above, recursing on the fix-point variable X (lines 7 and 9 ). Line 8 shows our earlier formula [ Srv : Clt ! { bye , Tot } when Tot < 0 ] ff that then checks for the condition imposed by P 1 . There are a couple of comments that are in order. First, the constraints on lines 8 and 9 ensure mutual exclusivity between the two necessities, i.e. either Tot < 0 or, Ans >= 0 only when the acknowledgement is the atom bye . Second, you may observe that the sub-formula on line 8 alone seems to capture the core requirement of property P 1 . This line of reasoning is partially right. However, to interpret the requirement stated informally (in English) by P 1 and formalise it unambiguously , one must take the transition model into account. In fact, formalising P 1 for a different transition system potentially yields a specification that is altogether unlike the one above for our calculator server. Specific to our transition model, the necessities lines 7 and 9 \u2018eat up\u2019 our non-relevant program events. Note Variables Lnc , Srv , and Clt in our formalisation of P 1 are included assist in our explanation, but can be replaced with the don\u2019t care pattern _ since these are unused in constraints. We omit such variables in the sequel. Reformulating P 1 \u00b6 P 1 safeguards against the calculator returning a negative request total when shut down. An examination of calc_server : loop / 1 promptly reveals that a non-negative request total returned on server shutdown does not necessarily mean that the number of tracked client requests is correct. In fact, starting the server loop with any number other than 0 will always yield an incorrect request total. Let us rectify this oversight by reformulating P 1 . (P\u2019 1 ) The service request count upon initialisation is never negative. Its corresponding formalisation leverages the init event pattern, simplifying the formula considerably: 1 2 3 4 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop ([ Tot ]) where Tot < 0 ] ff ). Line 4 consists of the singleton conjuncted necessity where the event pattern matches the spawned function against the module and function name atoms, calc_server and loop , respectively. The list pattern [] matches the argument list containing exactly one argument whose value is not negative, i.e. when Tot < 0 . Formalising P 2 \u00b6 (P 2 ) Replies are always sent to the client indicated in the request. P 2 describes a fragment of the client-server protocol, asserting that server replies are always addressed to the clients issuing them. Unlike the properties seen thus far, this requirement induces data dependency between client requests and server responses. 1 2 3 4 5 6 7 8 9 10 11 12 13 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] max ( X . and ([ Srv_1 ? { Clt_1 , _}] and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =/= Clt_2 ] ff , [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] X ) ) ) ). Our formalisation of P 2 expresses this data dependency in the nested formulae above via the binders Srv_1 and Clt_1 , that are used in the constraint of the sub-formulae on lines 8 and 9 . Srv_1 =:= Srv_2 scopes our reasoning to single server instance, i.e. the same calculator server process. The formula is violated when Clt_1 =/= Clt_2 (since the continuation would need to satisfy ff ), and recurs on variable X otherwise. Recall that the comparisons between the different variable instantiations is possible since the binding scope of the event pattern variables Srv_1 and Clt_1 in the outer necessity extends to the context of the inner and (...) on lines 7 - 10 . Refining P 2 \u00b6 The formalisation of P 2 above does not account for the case where the server interacts with more than one client. It disregards the possibility of interleaved execution, which is inherent to concurrent settings where processes are unable to control when messages are received. For instance, while the sub-formula [ Srv_1 ? { Clt_1 , _}] on line 6 matches an initial recv event, an ensuing recv event ( e.g. due to a second client that happens to interact with the server) satisfies neither of the necessities on lines 8 and 9 . This does not reflect the requirement of our original property P 2 , and is yet another manifestation of the issue encountered earlier , i.e. formalising a property must be done in connection to the context in which the program operates. We handle this inconvenience by augmenting the formula to filter non-relevant events, as previous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] max ( X . and ([ Srv_1 ? { Clt_1 , _}] max ( Y . and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =/= Clt_2 ] ff , [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] X , [_ ? _ ] Y ) ) ) ) ). Formalising P 3 \u00b6 (P 3 ) Client requests are never serviced more than once. P 3 specifies a control aspect of the client-server interaction. The corresponding sHML formula expresses this requirement via a guarded fix-point that recurs on X for sequences of send - recv events. This recursion captures normal server operation that corresponds to the sub-formula on line 5 followed by the one on line 7 , and then [_ ? _] X on line 4 followed thereafter by the sub-formula of line 7 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] and ([_ ? _] max ( X . and ([ Srv_1 : Clt_1 ! _] and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] ff , [_ ? _] X ) ) ) ) ). Our formula is violated when a send event matched by [ Srv_1 : Clt_1 ! _] is followed by a second send that is matched by the sub-formula on line 9 . The constraint Clt_1 =:= Clt_2 of the necessity on line 9 ensures that duplicate send events concern the same recipient. Having formalised properties P 1 , P 2 and P 3 , we are now in a position to use detectEr and synthesise the corresponding analysers in Erlang code.","title":"Formalising Properties"},{"location":"using-detecter/formalising-properties.html#formalising-properties","text":"","title":"Formalising Properties"},{"location":"using-detecter/formalising-properties.html#choosing-what-to-analyse","text":"detectEr provides the keywords with and monitor to target program processes for a particular sHML specification. The with keyword picks out the signature of the function that is spawned as a process, whereas the monitor keyword defines the property to be runtime analysed. For example, to verify the behaviour of our calculator process against a sHML formula \u03c6 , we write: with calc_server : loop (_) monitor \u03c6 From an instrumentation standpoint, with establishes the set of trace events corresponding to the program process it targets, thus enabling the specification to abstract from the events that are generated by other processes. This helps maintain the size of sHML specifications compact whenever possible. In using with , our formula need not account for superfluous trace events ( e.g. of another calculator process) that tend to make the specification exercise tedious and error-prone. Let us formalise the properties from the Getting Started section; these are specified with respect to the five process events fork , init , exit , send , and recv supported by detectEr. We include our calculator server transition model for reference. @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro);&#xa;@import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt,stp} Srv ? {Clt,stp} Srv:Clt ! {bye,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! {ok,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{A,B}} Srv ? {Clt,{A,B}} Srv:Clt ! {ok,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{A,B}} Srv ? {Clt,{A,B}} Viewer does not support full SVG 1.1","title":"Choosing what to analyse"},{"location":"using-detecter/formalising-properties.html#formalising-p1","text":"(P 1 ) The service request count returned on shutdown is never negative. P 1 is an extension of the property that we have already seen earlier, and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff , that requires the program state \u201cnot to exhibit a send event whose payload consists of { bye , Tot } where Tot is negative.\u201d While in principle, this sHML formula is correct, it does not account for the other program events that our calculator server can exhibit from one of its states. For example, from Q0 , the server exhibits recv events that are ignored by the formula; similarly, from Q2 , the server transitions with a send event to Q1 , but the message payload is not the one we are after. We remedy this by adding clauses that handle these possibilities. 1 2 3 4 5 6 7 8 9 10 11 with calc_server : loop (_) monitor and ([ Lnc <- Srv , calc_server : loop ( Args )] max ( X . and ( [ Srv ? Clt ] X , [ Srv : Clt ! { bye , Tot } when Tot < 0 ] ff , [ Srv : Clt ! { Ack , Ans } when Ack =:= ok orelse ( Ack =:= bye andalso Ans >= 0 )] X ) ). Using with .. monitor , we designate the spawned calculator server loop function calc_server : loop / 1 as the process to be analysed against the formalisation of property P 1 (lines 1 - 3 ). Our formalisation of P 1 consists of two conjuncted necessities , i.e. and (...) . The first conjuncted necessity on line 4 handles the init event exhibited by every process upon initialisation (we remark that init was elided in the transition model of our calculator server to simplify our discussion, but we need to account for it!). The second nested and (...) on line 6 includes the additional necessities that cover the other possible events produced by the transition system above, recursing on the fix-point variable X (lines 7 and 9 ). Line 8 shows our earlier formula [ Srv : Clt ! { bye , Tot } when Tot < 0 ] ff that then checks for the condition imposed by P 1 . There are a couple of comments that are in order. First, the constraints on lines 8 and 9 ensure mutual exclusivity between the two necessities, i.e. either Tot < 0 or, Ans >= 0 only when the acknowledgement is the atom bye . Second, you may observe that the sub-formula on line 8 alone seems to capture the core requirement of property P 1 . This line of reasoning is partially right. However, to interpret the requirement stated informally (in English) by P 1 and formalise it unambiguously , one must take the transition model into account. In fact, formalising P 1 for a different transition system potentially yields a specification that is altogether unlike the one above for our calculator server. Specific to our transition model, the necessities lines 7 and 9 \u2018eat up\u2019 our non-relevant program events. Note Variables Lnc , Srv , and Clt in our formalisation of P 1 are included assist in our explanation, but can be replaced with the don\u2019t care pattern _ since these are unused in constraints. We omit such variables in the sequel.","title":"Formalising P1"},{"location":"using-detecter/formalising-properties.html#reformulating-p1","text":"P 1 safeguards against the calculator returning a negative request total when shut down. An examination of calc_server : loop / 1 promptly reveals that a non-negative request total returned on server shutdown does not necessarily mean that the number of tracked client requests is correct. In fact, starting the server loop with any number other than 0 will always yield an incorrect request total. Let us rectify this oversight by reformulating P 1 . (P\u2019 1 ) The service request count upon initialisation is never negative. Its corresponding formalisation leverages the init event pattern, simplifying the formula considerably: 1 2 3 4 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop ([ Tot ]) where Tot < 0 ] ff ). Line 4 consists of the singleton conjuncted necessity where the event pattern matches the spawned function against the module and function name atoms, calc_server and loop , respectively. The list pattern [] matches the argument list containing exactly one argument whose value is not negative, i.e. when Tot < 0 .","title":"Reformulating P1"},{"location":"using-detecter/formalising-properties.html#formalising-p2","text":"(P 2 ) Replies are always sent to the client indicated in the request. P 2 describes a fragment of the client-server protocol, asserting that server replies are always addressed to the clients issuing them. Unlike the properties seen thus far, this requirement induces data dependency between client requests and server responses. 1 2 3 4 5 6 7 8 9 10 11 12 13 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] max ( X . and ([ Srv_1 ? { Clt_1 , _}] and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =/= Clt_2 ] ff , [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] X ) ) ) ). Our formalisation of P 2 expresses this data dependency in the nested formulae above via the binders Srv_1 and Clt_1 , that are used in the constraint of the sub-formulae on lines 8 and 9 . Srv_1 =:= Srv_2 scopes our reasoning to single server instance, i.e. the same calculator server process. The formula is violated when Clt_1 =/= Clt_2 (since the continuation would need to satisfy ff ), and recurs on variable X otherwise. Recall that the comparisons between the different variable instantiations is possible since the binding scope of the event pattern variables Srv_1 and Clt_1 in the outer necessity extends to the context of the inner and (...) on lines 7 - 10 .","title":"Formalising P2"},{"location":"using-detecter/formalising-properties.html#refining-p2","text":"The formalisation of P 2 above does not account for the case where the server interacts with more than one client. It disregards the possibility of interleaved execution, which is inherent to concurrent settings where processes are unable to control when messages are received. For instance, while the sub-formula [ Srv_1 ? { Clt_1 , _}] on line 6 matches an initial recv event, an ensuing recv event ( e.g. due to a second client that happens to interact with the server) satisfies neither of the necessities on lines 8 and 9 . This does not reflect the requirement of our original property P 2 , and is yet another manifestation of the issue encountered earlier , i.e. formalising a property must be done in connection to the context in which the program operates. We handle this inconvenience by augmenting the formula to filter non-relevant events, as previous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] max ( X . and ([ Srv_1 ? { Clt_1 , _}] max ( Y . and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =/= Clt_2 ] ff , [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] X , [_ ? _ ] Y ) ) ) ) ).","title":"Refining P2"},{"location":"using-detecter/formalising-properties.html#formalising-p3","text":"(P 3 ) Client requests are never serviced more than once. P 3 specifies a control aspect of the client-server interaction. The corresponding sHML formula expresses this requirement via a guarded fix-point that recurs on X for sequences of send - recv events. This recursion captures normal server operation that corresponds to the sub-formula on line 5 followed by the one on line 7 , and then [_ ? _] X on line 4 followed thereafter by the sub-formula of line 7 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] and ([_ ? _] max ( X . and ([ Srv_1 : Clt_1 ! _] and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] ff , [_ ? _] X ) ) ) ) ). Our formula is violated when a send event matched by [ Srv_1 : Clt_1 ! _] is followed by a second send that is matched by the sub-formula on line 9 . The constraint Clt_1 =:= Clt_2 of the necessity on line 9 ensures that duplicate send events concern the same recipient. Having formalised properties P 1 , P 2 and P 3 , we are now in a position to use detectEr and synthesise the corresponding analysers in Erlang code.","title":"Formalising P3"},{"location":"using-detecter/getting-started.html","text":"Getting Started \u00b6 A Calculator program in Erlang \u00b6 Let us consider an archetypal calculator program consisting of a single server process that handles client requests for arithmetic computation. The calculator server blocks and waits for requests sent as asynchronous messages. These messages are addressed to the server using its PID , and deposited in the server mailbox that buffers multiple client requests. The calculator server unblocks upon reading a message from its mailbox. In our client-server protocol, messages contain the type of operation to be executed on the server side, its arguments (if applicable), and the client PID to whom the corresponding server reply is addressed. Our calculator program is implemented as the Erlang module calc_server that can be found under examples/erlang/src . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 start ( N ) -> spawn ( ? MODULE , loop , [ N ]). loop ( Tot ) -> receive { Clt , { add , A , B }} -> Clt ! { ok , A + B }, loop ( Tot + 1 ); { Clt , { mul , A , B }} -> Clt ! { ok , A * B }, loop ( Tot + 1 ); { Clt , stp } -> % Stop service. Clt ! { bye , Tot } end . calc_server : loop / 1 encapsulates the calculator server logic that is spawned by some other launcher process ( e.g. the Erlang shell) that invokes calc_server : start / 1 for some integer argument N . The spawned server consumes a message request from its mailbox via the receive expression on lines 5-16 , and pattern matches against one of the three types of operations requested by clients: Addition ( add ) and multiplication ( mul ) requests that carry the operands A and B (lines 6 and 10 ), and, stop ( stp ) requests that carries no arguments (line 14 ). Pattern matching instantiates the variables Clt , A and B to concrete data in client request messages. Every request fulfilled by the server results in a corresponding reply that it sends to the PID of the client instantiated in variable Clt , lines 6 , 10 , and 14 . Server replies carry the status tag (an atom) ok or bye , and the result of the requested operation. The server uses the parameter Tot of loop / 1 to track the number of requests serviced, and is returned in reply to a stp operation. After handling add and mul requests, the server executes loop / 1 to recommence the process loop and service the next client request, incrementing the request count accordingly (lines 8 and 12 ); the tail recursive call to loop / 1 is not made for stp requests, and the calculator server process terminates naturally. The logic of loop / 1 induces a server runtime behaviour that can be abstractly described by the transition system model below. @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro);&#xa;@import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt,stp} Srv ? {Clt,stp} Srv:Clt ! {bye,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! {ok,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{A,B}} Srv ? {Clt,{A,B}} Srv:Clt ! {ok,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{A,B}} Srv ? {Clt,{A,B}} Viewer does not support full SVG 1.1 States of the model capture the internal state that the server process can be in at any point during its execution. Transitions between states denote the computational steps of the program that produce visible program events . For instance, the event Srv ? { Clt , stp } is exhibited by the server loop when the calculator at its initial state Q0 reads a stp request from its mailbox and transitions to Q3 . This transition depicts the computation that loop / 1 performs to receive the stp request, line 5 , and subsequently pattern match it to { Clt , stp } on line 14 . Note that events in the model capture the set of all possible concrete events that the running program can exhibit, e.g. , Srv ? { Clt , stp } describes all receive events where the variable placeholders Srv and Clt range over PIDs , and stp is the atom denoting the stop operation requested by clients. Safety properties \u00b6 There are a number of properties we would like the server behaviour to observe. For example, the server loop does not control the initial value of Tot that an invocation to calc_server : start / 1 provides. We could, therefore, require that: (P 1 ) The service request count returned on shutdown is never negative. Similarly, we would expect that (P 2 ) Replies are always sent to the client indicated in the request, and that \u201cA request for adding two numbers always returns their sum\u201d both hold, amongst others. These properties are data-dependent , which makes them hard to ascertain using static techniques such as type systems. Besides properties that reason about data, our server logic is expected to comply with control properties, such as, (P 3 ) Client requests are never serviced more than once. The properties mentioned thus far phrase the correctness requirement as a guarantee that the program must always provide. Such properties are called safety properties , since they stipulate that \u201cfor any sort of behaviour that the program can do, nothing bad ever happens.\u201d As a consequence of this condition, showing that a program violates a safety property entails finding just one instance of a program execution that exhibits bad behaviour. Producing this evidence is enough of a proof that the program under scrutiny is not safe with respect to the property in question. The next section explains how these properties can be expressed in a logic that precisely and unambiguously establishes the behaviour programs must comply with.","title":"Getting Started"},{"location":"using-detecter/getting-started.html#getting-started","text":"","title":"Getting Started"},{"location":"using-detecter/getting-started.html#a-calculator-program-in-erlang","text":"Let us consider an archetypal calculator program consisting of a single server process that handles client requests for arithmetic computation. The calculator server blocks and waits for requests sent as asynchronous messages. These messages are addressed to the server using its PID , and deposited in the server mailbox that buffers multiple client requests. The calculator server unblocks upon reading a message from its mailbox. In our client-server protocol, messages contain the type of operation to be executed on the server side, its arguments (if applicable), and the client PID to whom the corresponding server reply is addressed. Our calculator program is implemented as the Erlang module calc_server that can be found under examples/erlang/src . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 start ( N ) -> spawn ( ? MODULE , loop , [ N ]). loop ( Tot ) -> receive { Clt , { add , A , B }} -> Clt ! { ok , A + B }, loop ( Tot + 1 ); { Clt , { mul , A , B }} -> Clt ! { ok , A * B }, loop ( Tot + 1 ); { Clt , stp } -> % Stop service. Clt ! { bye , Tot } end . calc_server : loop / 1 encapsulates the calculator server logic that is spawned by some other launcher process ( e.g. the Erlang shell) that invokes calc_server : start / 1 for some integer argument N . The spawned server consumes a message request from its mailbox via the receive expression on lines 5-16 , and pattern matches against one of the three types of operations requested by clients: Addition ( add ) and multiplication ( mul ) requests that carry the operands A and B (lines 6 and 10 ), and, stop ( stp ) requests that carries no arguments (line 14 ). Pattern matching instantiates the variables Clt , A and B to concrete data in client request messages. Every request fulfilled by the server results in a corresponding reply that it sends to the PID of the client instantiated in variable Clt , lines 6 , 10 , and 14 . Server replies carry the status tag (an atom) ok or bye , and the result of the requested operation. The server uses the parameter Tot of loop / 1 to track the number of requests serviced, and is returned in reply to a stp operation. After handling add and mul requests, the server executes loop / 1 to recommence the process loop and service the next client request, incrementing the request count accordingly (lines 8 and 12 ); the tail recursive call to loop / 1 is not made for stp requests, and the calculator server process terminates naturally. The logic of loop / 1 induces a server runtime behaviour that can be abstractly described by the transition system model below. @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro);&#xa;@import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt,stp} Srv ? {Clt,stp} Srv:Clt ! {bye,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! {ok,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{A,B}} Srv ? {Clt,{A,B}} Srv:Clt ! {ok,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{A,B}} Srv ? {Clt,{A,B}} Viewer does not support full SVG 1.1 States of the model capture the internal state that the server process can be in at any point during its execution. Transitions between states denote the computational steps of the program that produce visible program events . For instance, the event Srv ? { Clt , stp } is exhibited by the server loop when the calculator at its initial state Q0 reads a stp request from its mailbox and transitions to Q3 . This transition depicts the computation that loop / 1 performs to receive the stp request, line 5 , and subsequently pattern match it to { Clt , stp } on line 14 . Note that events in the model capture the set of all possible concrete events that the running program can exhibit, e.g. , Srv ? { Clt , stp } describes all receive events where the variable placeholders Srv and Clt range over PIDs , and stp is the atom denoting the stop operation requested by clients.","title":"A Calculator program in Erlang"},{"location":"using-detecter/getting-started.html#safety-properties","text":"There are a number of properties we would like the server behaviour to observe. For example, the server loop does not control the initial value of Tot that an invocation to calc_server : start / 1 provides. We could, therefore, require that: (P 1 ) The service request count returned on shutdown is never negative. Similarly, we would expect that (P 2 ) Replies are always sent to the client indicated in the request, and that \u201cA request for adding two numbers always returns their sum\u201d both hold, amongst others. These properties are data-dependent , which makes them hard to ascertain using static techniques such as type systems. Besides properties that reason about data, our server logic is expected to comply with control properties, such as, (P 3 ) Client requests are never serviced more than once. The properties mentioned thus far phrase the correctness requirement as a guarantee that the program must always provide. Such properties are called safety properties , since they stipulate that \u201cfor any sort of behaviour that the program can do, nothing bad ever happens.\u201d As a consequence of this condition, showing that a program violates a safety property entails finding just one instance of a program execution that exhibits bad behaviour. Producing this evidence is enough of a proof that the program under scrutiny is not safe with respect to the property in question. The next section explains how these properties can be expressed in a logic that precisely and unambiguously establishes the behaviour programs must comply with.","title":"Safety properties"},{"location":"using-detecter/instrumentation.html","text":"Instrumentation \u00b6 Types of instrumentation detecter supports. Diagram of the system architecture. How the same generated analyzer code is used to instrument the Erlang, Elixir and Python setups. Generating the monitor \u00b6 This is a common aspect to all types of instrumentation. Treating it centrally reinforces this fact. Inline instrumentation \u00b6 We reintroduce the erlang system code. The erroneous system here is on P1 Outline instrumentation \u00b6 We introduce the elixir system code. The erroneous system here is on P2. Outline instrumentation \u00b6 We introduce the python system code. The erroneous system here is on P3. As system implementations (for the tutorial), we should have: The good system for all language implementations. The system that violates P1 for just erlang. The system that violates P2 for just elixir. The system that violates P3 for just python, doris! We also need the updated parser.","title":"Instrumentation"},{"location":"using-detecter/instrumentation.html#instrumentation","text":"Types of instrumentation detecter supports. Diagram of the system architecture. How the same generated analyzer code is used to instrument the Erlang, Elixir and Python setups.","title":"Instrumentation"},{"location":"using-detecter/instrumentation.html#generating-the-monitor","text":"This is a common aspect to all types of instrumentation. Treating it centrally reinforces this fact.","title":"Generating the monitor"},{"location":"using-detecter/instrumentation.html#inline-instrumentation","text":"We reintroduce the erlang system code. The erroneous system here is on P1","title":"Inline instrumentation"},{"location":"using-detecter/instrumentation.html#outline-instrumentation","text":"We introduce the elixir system code. The erroneous system here is on P2.","title":"Outline instrumentation"},{"location":"using-detecter/instrumentation.html#outline-instrumentation_1","text":"We introduce the python system code. The erroneous system here is on P3. As system implementations (for the tutorial), we should have: The good system for all language implementations. The system that violates P1 for just erlang. The system that violates P2 for just elixir. The system that violates P3 for just python, doris! We also need the updated parser.","title":"Outline instrumentation"},{"location":"using-detecter/runtime-verification.html","text":"Runtime Verification \u00b6 A partial view of the program model \u00b6 Let us recall the calculator server and its transition model. @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro);&#xa;@import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt,stp} Srv ? {Clt,stp} Srv:Clt ! {bye,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! {ok,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{A,B}} Srv ? {Clt,{A,B}} Srv:Clt ! {ok,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{A,B}} Srv ? {Clt,{A,B}} Viewer does not support full SVG 1.1 From its initial state Q0 , the transition system modelling the behaviour of calc_server : loop / 1 can follow three different paths. This branching structure is induced by the receive expression, that introduces a choice between which clause to execute, depending on the pattern match that succeeds. The transition model thus gives us an exhaustive description of the paths that the calculator server can take at runtime, affording us full visibility about what the program is able to do. Notably, this information is available prior to runtime, and is what certain static verification techniques such as model checking rely upon. There are however cases where static approaches cannot be employed, e.g. the program transition model is not available, or is infeasible to construct. Runtime Verification is a post-deployment technique [] that can be used instead of\u2014or in tandem with\u2014static techniques to increase correctness assurances about a program under scrutiny. detectEr is one such RV tool for asynchronous component systems that can analyse the behaviour of programs running on, or outside the EVM . Post-deployment verification techniques such as RV often to not have access to the entire transition model of a program. Rather, their view of the system is limited to just to the sequence of events generated by the current program execution. This linear sequence of program event is known as the execution trace , or trace , for short. For instance, our calculator program might generate the trace of events \u2018 < 0 . 10 . 0 > ? { < 0 . 16 . 0 > , stp } . < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , 1 } \u2019. This corresponds to the (finite) path traversal Q0 \u2192 Srv ? { Clt , stp } \u2192 Q3 \u2192 Srv:Clt ! {bye, Tot} in the transition model above, where Srv = < 0 . 10 . 0 > , Clt = < 0 . 16 . 0 > , and Tot = 1 . Is one trace enough? \u00b6 One natural question that may occur to you at this point is whether a mere sliver of the (more expressive) program transition model is sufficient for us to conclude anything of value about the program under analysis. Answers to this question depend on various aspects: What logic are we using to express properties? There are logics that can reason about states of the program transition model ( e.g. \u03bc-calculus, HML, CTL), while others can only reason on traces ( e.g. , LTL). Are the traces we consider finite or infinite? There are logics that can Adrian fill in How many traces do we have available? There are cases where more than one trace is available, e.g. the program is executed multiple times, or the program consists of concurrent components that produce different interleaved executions. This produces additional runtime information that we can leverage. This field of study is called monitorability , and has been treated at length in various works[REFS]. For us, it is enough to know that sHML \u2014the logic detectEr uses\u2014is runtime monitorable with respect to violations [REFS]. This means that any program that violates a property expressed as a sHML formula can be detected by analysing just one trace check . The intuition as to why this is the case is as follows. Recall that the sHML formula [ \u03b1 ] \u03c6 requires that all the outgoing paths from some state of the program transition system satisfy the symbolic action \u03b1 , and the next state then satisfies the continuation \u03c6 . To show that a program transition system ( not just one path!) violates the sHML property, it suffices to find one path in the transition system that goes against the what property stipulates. Trace events, in practice \u00b6 When it comes to tooling, the representation of trace events tends to be implementation-specific and is often tied to the chosen language framework. To make the specification of sHML properties intuitive, detectEr employs the intermediate representation seen earlier , consisting of the program events, fork , init , exit , send and recv . detectEr translates this intermediate representation to the format used by the native tracing infrastructure of the EVM , and is covered in the Synthesising Analysers section. We next learn how the safety properties P 1 , P 2 and P 3 stated informally can be expressed in sHML .","title":"Runtime Verification"},{"location":"using-detecter/runtime-verification.html#runtime-verification","text":"","title":"Runtime Verification"},{"location":"using-detecter/runtime-verification.html#a-partial-view-of-the-program-model","text":"Let us recall the calculator server and its transition model. @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro);&#xa;@import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt,stp} Srv ? {Clt,stp} Srv:Clt ! {bye,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! {ok,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{A,B}} Srv ? {Clt,{A,B}} Srv:Clt ! {ok,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{A,B}} Srv ? {Clt,{A,B}} Viewer does not support full SVG 1.1 From its initial state Q0 , the transition system modelling the behaviour of calc_server : loop / 1 can follow three different paths. This branching structure is induced by the receive expression, that introduces a choice between which clause to execute, depending on the pattern match that succeeds. The transition model thus gives us an exhaustive description of the paths that the calculator server can take at runtime, affording us full visibility about what the program is able to do. Notably, this information is available prior to runtime, and is what certain static verification techniques such as model checking rely upon. There are however cases where static approaches cannot be employed, e.g. the program transition model is not available, or is infeasible to construct. Runtime Verification is a post-deployment technique [] that can be used instead of\u2014or in tandem with\u2014static techniques to increase correctness assurances about a program under scrutiny. detectEr is one such RV tool for asynchronous component systems that can analyse the behaviour of programs running on, or outside the EVM . Post-deployment verification techniques such as RV often to not have access to the entire transition model of a program. Rather, their view of the system is limited to just to the sequence of events generated by the current program execution. This linear sequence of program event is known as the execution trace , or trace , for short. For instance, our calculator program might generate the trace of events \u2018 < 0 . 10 . 0 > ? { < 0 . 16 . 0 > , stp } . < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , 1 } \u2019. This corresponds to the (finite) path traversal Q0 \u2192 Srv ? { Clt , stp } \u2192 Q3 \u2192 Srv:Clt ! {bye, Tot} in the transition model above, where Srv = < 0 . 10 . 0 > , Clt = < 0 . 16 . 0 > , and Tot = 1 .","title":"A partial view of the program model"},{"location":"using-detecter/runtime-verification.html#is-one-trace-enough","text":"One natural question that may occur to you at this point is whether a mere sliver of the (more expressive) program transition model is sufficient for us to conclude anything of value about the program under analysis. Answers to this question depend on various aspects: What logic are we using to express properties? There are logics that can reason about states of the program transition model ( e.g. \u03bc-calculus, HML, CTL), while others can only reason on traces ( e.g. , LTL). Are the traces we consider finite or infinite? There are logics that can Adrian fill in How many traces do we have available? There are cases where more than one trace is available, e.g. the program is executed multiple times, or the program consists of concurrent components that produce different interleaved executions. This produces additional runtime information that we can leverage. This field of study is called monitorability , and has been treated at length in various works[REFS]. For us, it is enough to know that sHML \u2014the logic detectEr uses\u2014is runtime monitorable with respect to violations [REFS]. This means that any program that violates a property expressed as a sHML formula can be detected by analysing just one trace check . The intuition as to why this is the case is as follows. Recall that the sHML formula [ \u03b1 ] \u03c6 requires that all the outgoing paths from some state of the program transition system satisfy the symbolic action \u03b1 , and the next state then satisfies the continuation \u03c6 . To show that a program transition system ( not just one path!) violates the sHML property, it suffices to find one path in the transition system that goes against the what property stipulates.","title":"Is one trace enough?"},{"location":"using-detecter/runtime-verification.html#trace-events-in-practice","text":"When it comes to tooling, the representation of trace events tends to be implementation-specific and is often tied to the chosen language framework. To make the specification of sHML properties intuitive, detectEr employs the intermediate representation seen earlier , consisting of the program events, fork , init , exit , send and recv . detectEr translates this intermediate representation to the format used by the native tracing infrastructure of the EVM , and is covered in the Synthesising Analysers section. We next learn how the safety properties P 1 , P 2 and P 3 stated informally can be expressed in sHML .","title":"Trace events, in practice"},{"location":"using-detecter/synthesising-analysers.html","text":"Explains how to generate analysers using the tool \u00b6 Explains the code and events (and also the code that handles inconclusivity) \u00b6 Specify a simple property and explain the synthesised code, giving an example of how the events are consumed and processed. Probably it will be the first property in the paper or else, the second one for which we have the automaton and we can show the corresponding code generated in Erlang. Must come after the RV section. \u00b6 Inconclusive verdicts and how they work \u00b6 List the possible traces","title":"Explains how to generate analysers using the tool"},{"location":"using-detecter/synthesising-analysers.html#explains-how-to-generate-analysers-using-the-tool","text":"","title":"Explains how to generate analysers using the tool"},{"location":"using-detecter/synthesising-analysers.html#explains-the-code-and-events-and-also-the-code-that-handles-inconclusivity","text":"Specify a simple property and explain the synthesised code, giving an example of how the events are consumed and processed. Probably it will be the first property in the paper or else, the second one for which we have the automaton and we can show the corresponding code generated in Erlang.","title":"Explains the code and events (and also the code that handles inconclusivity)"},{"location":"using-detecter/synthesising-analysers.html#must-come-after-the-rv-section","text":"","title":"Must come after the RV section."},{"location":"using-detecter/synthesising-analysers.html#inconclusive-verdicts-and-how-they-work","text":"List the possible traces","title":"Inconclusive verdicts and how they work"},{"location":"using-detecter/the-specification-logic.html","text":"The Specification Logic \u00b6 Overview \u00b6 For the sake of simplicity, the script hello_prop.hml used in our hello world example specifies a sHML property that every system necessarily violates, namely, the formula ff that denotes falsity. We now look at the full sHML grammar that enables us to express more interesting and useful properties about programs (not traces). Specifications in sHML \u2014also called formulae \u2014are interpreted over the states of transition models of programs we wish to analyse. sHML is a syntactic subset of the more expressive Hennessy-Milner Logic with recursion, and is used to specify safety properties . Recall safety properties state that \u201csomething bad should never happen\u201d. sHML formulae are generated from the following grammar: \u03c6 \u2208 sHML :: = ff | tt (1) | X (2) | max ( X . \u03c6 ) (3) | and ([ \u03b1\u2081 ] \u03c6\u2081 , ..., [ \u03b1\u2099 ] \u03c6\u2099 ) (4) Formulae ff and tt denote falsity and truth respectively, X is a logical variable , The maximal fix-point construct specifies recursion via the logical variable X and binds the free occurrences of X in the sub-formula \u03c6 , and, and (...) is a sequence of comma-separated conjunctions where each conjunct is a sub-formula \u03c6\u1d62 guarded by the universal modal operator [ \u03b1\u1d62 ] (also called a necessity ). To handle reasoning over program event data, the modal operator is equipped with symbolic actions \u03b1 of the form P when C , where P is an event pattern and C , a decidable Boolean constraint . Patterns correspond to events that the program under analysis exhibits. These patterns contain data variables that are instantiated with values learnt at runtime from matched events. Pattern variables bind the free variables in constraints C , and this binding scope extends to the continuation formula \u03c6 . Symbolic action patterns follow the pattern-matching syntax of Erlang and Elixir, where atoms are matched directly, and the \u2018don\u2019t care\u2019 pattern _ matches any data value. Central to the conjuncted necessities construct, and ([ \u03b1\u2081 ] \u03c6\u2081 , ..., [ \u03b1\u2099 ] \u03c6\u2099 ) , is the constraint that at any one point in time, at most one conjunct [ \u03b1\u1d62 ] \u03c6\u1d62 may be satisfied. This enables detectEr to synthesise deterministic analyser code [Refs:Antoins,IAN,TutPaper]. We say that a program (or a program state) satisfies the formula [ P when C ] \u03c6 whenever it exhibits an event that matches pattern P , fulfils the constraint C , and the ensuing program behaviour then satisfies \u03c6 . When the constraint is true , the expression when C may be omitted for readability. Pattern and constraint expressions \u00b6 detectEr supports five event patterns describing the lifecycle of processes. A fork action is exhibited by a process when it spawns a new child process; its dual, init , is exhibited by the corresponding child upon initialisation. Process exit actions signal termination, while send and recv describe process interaction. Program event Event pattern Pattern variable Description fork P\u2081 \u2192 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments init P\u2081 \u2190 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments exit P\u2081 ** Data P\u2081 PID of the terminated process Data Termination data send P\u2081 : P\u2082 ! Msg P\u2081 PID of the process issuing the message P\u2082 PID of the recipient process Msg Message payload recv P\u2082 ? Msg P\u2082 PID of the recipient process Msg Request payload consisting of data The variables P\u2081 and P\u2082 in event patterns must be a port ID or PID , whereas Data and Msg may be any Erlang data type , i.e. , one of atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Mod and Fun must be atoms, and Args , an arbitrary list comprised of the aforementioned data types. Pattern matching Our current detectEr syntax does not yet implement full Erlang pattern matching, including $, map, record and bit string expressions; these will be added in future releases of the tool. Note that these data values can still be used in patterns, so long as the pattern matching expression does not unwrap the individual data components of these values. For instance, the pattern Var = Map is acceptable whereas #{K := V} = Map is not; similarly, Var = List may be used but not [$d, $a | _] = List . Constraint definitions on pattern variables used by detectEr correspond to Erlang guard sequences consisting of guard expressions . The set of valid Erlang guards supported by detectEr are the following: Variables. Values, i.e. , atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Expressions constructing atoms, integer, floats, lists, and tuples. Term comparisons. Operator Description == Equal to /= Not equal to =< Less than or equal to < Less than >= Greater than or equal to > Greater than =:= Exactly equal to =/= Exactly not equal to Arithmetic expressions. Operator Description Argument Type + Unary addition Number - Unary subtraction Number + Addition Number - Subtraction Number * Multiplication Number / Floating point division Number bnot Unary bitwise NOT Integer div Integer division Integer rem Integer remainder of X/Y Integer band Bitwise AND Integer bor Bitwise OR Integer bxor Arithmetic bitwise XOR Integer bsl Arithmetic bit shift left Integer bsr Bit shift right Integer Boolean expressions. Operator Description not Unary logical NOT and Logical AND or Logical OR xor Logical XOR Short-circuit expressions andalso , orelse . A simple example \u00b6 Let us try to specify a safety requirement on the behaviour of our calculator program . The sHML formula with symbolic action Srv : Clt ! { bye , Tot } when Tot < 0 describes the property requiring that \u201cthe program state does not exhibit a send event whose payload consists of { bye , Tot } with a negative total: and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff Recall that the universal modality states that, for any program event satisfying the symbolic action P when C in [ P when C ] \u03c6 , the ensuing program behaviour must then satisfy the continuation formula \u03c6 . However, no program state can satisfy the continuation ff ! This means that the formula and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff can only be satisfied when our calculator program does not exhibit the event described by the symbolic action Srv : Clt ! { bye , Tot } when Tot < 0 . Suppose our server with PID < 0 . 10 . 0 > exhibits the send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , - 1 } in response to a request issued by a client with PID < 0 . 16 . 0 > . It matches pattern Srv : Clt ! { bye , Tot } , instantiating the variables Srv = < 0 . 10 . 0 > , Clt = < 0 . 16 . 0 > , and Tot = - 1 . The constraint when Tot < 0 is also satisfied by Tot , leading to a violation, i.e. , ff . For a different send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , 1 } , the symbolic action in the modality [ Srv : Clt ! { bye , Tot } when Tot < 0 ] is not satisfied, and consequently, and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff is not violated. Analogously, the exit event < 0 . 10 . 0 > ** killed does not lead to a violation of the formula since the pattern Srv : Clt ! { bye , Tot } fails to match the event shape. Cheat sheet The formula [ \u03b1 ] ff means that the program must not perform the symbolic action \u03b1 . Despite the fact that the runtime setting limits what one observes at runtime, we next outline how this does not prevent us from verifying properties expressed in sHML .","title":"The Specification Logic"},{"location":"using-detecter/the-specification-logic.html#the-specification-logic","text":"","title":"The Specification Logic"},{"location":"using-detecter/the-specification-logic.html#overview","text":"For the sake of simplicity, the script hello_prop.hml used in our hello world example specifies a sHML property that every system necessarily violates, namely, the formula ff that denotes falsity. We now look at the full sHML grammar that enables us to express more interesting and useful properties about programs (not traces). Specifications in sHML \u2014also called formulae \u2014are interpreted over the states of transition models of programs we wish to analyse. sHML is a syntactic subset of the more expressive Hennessy-Milner Logic with recursion, and is used to specify safety properties . Recall safety properties state that \u201csomething bad should never happen\u201d. sHML formulae are generated from the following grammar: \u03c6 \u2208 sHML :: = ff | tt (1) | X (2) | max ( X . \u03c6 ) (3) | and ([ \u03b1\u2081 ] \u03c6\u2081 , ..., [ \u03b1\u2099 ] \u03c6\u2099 ) (4) Formulae ff and tt denote falsity and truth respectively, X is a logical variable , The maximal fix-point construct specifies recursion via the logical variable X and binds the free occurrences of X in the sub-formula \u03c6 , and, and (...) is a sequence of comma-separated conjunctions where each conjunct is a sub-formula \u03c6\u1d62 guarded by the universal modal operator [ \u03b1\u1d62 ] (also called a necessity ). To handle reasoning over program event data, the modal operator is equipped with symbolic actions \u03b1 of the form P when C , where P is an event pattern and C , a decidable Boolean constraint . Patterns correspond to events that the program under analysis exhibits. These patterns contain data variables that are instantiated with values learnt at runtime from matched events. Pattern variables bind the free variables in constraints C , and this binding scope extends to the continuation formula \u03c6 . Symbolic action patterns follow the pattern-matching syntax of Erlang and Elixir, where atoms are matched directly, and the \u2018don\u2019t care\u2019 pattern _ matches any data value. Central to the conjuncted necessities construct, and ([ \u03b1\u2081 ] \u03c6\u2081 , ..., [ \u03b1\u2099 ] \u03c6\u2099 ) , is the constraint that at any one point in time, at most one conjunct [ \u03b1\u1d62 ] \u03c6\u1d62 may be satisfied. This enables detectEr to synthesise deterministic analyser code [Refs:Antoins,IAN,TutPaper]. We say that a program (or a program state) satisfies the formula [ P when C ] \u03c6 whenever it exhibits an event that matches pattern P , fulfils the constraint C , and the ensuing program behaviour then satisfies \u03c6 . When the constraint is true , the expression when C may be omitted for readability.","title":"Overview"},{"location":"using-detecter/the-specification-logic.html#pattern-and-constraint-expressions","text":"detectEr supports five event patterns describing the lifecycle of processes. A fork action is exhibited by a process when it spawns a new child process; its dual, init , is exhibited by the corresponding child upon initialisation. Process exit actions signal termination, while send and recv describe process interaction. Program event Event pattern Pattern variable Description fork P\u2081 \u2192 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments init P\u2081 \u2190 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments exit P\u2081 ** Data P\u2081 PID of the terminated process Data Termination data send P\u2081 : P\u2082 ! Msg P\u2081 PID of the process issuing the message P\u2082 PID of the recipient process Msg Message payload recv P\u2082 ? Msg P\u2082 PID of the recipient process Msg Request payload consisting of data The variables P\u2081 and P\u2082 in event patterns must be a port ID or PID , whereas Data and Msg may be any Erlang data type , i.e. , one of atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Mod and Fun must be atoms, and Args , an arbitrary list comprised of the aforementioned data types. Pattern matching Our current detectEr syntax does not yet implement full Erlang pattern matching, including $, map, record and bit string expressions; these will be added in future releases of the tool. Note that these data values can still be used in patterns, so long as the pattern matching expression does not unwrap the individual data components of these values. For instance, the pattern Var = Map is acceptable whereas #{K := V} = Map is not; similarly, Var = List may be used but not [$d, $a | _] = List . Constraint definitions on pattern variables used by detectEr correspond to Erlang guard sequences consisting of guard expressions . The set of valid Erlang guards supported by detectEr are the following: Variables. Values, i.e. , atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Expressions constructing atoms, integer, floats, lists, and tuples. Term comparisons. Operator Description == Equal to /= Not equal to =< Less than or equal to < Less than >= Greater than or equal to > Greater than =:= Exactly equal to =/= Exactly not equal to Arithmetic expressions. Operator Description Argument Type + Unary addition Number - Unary subtraction Number + Addition Number - Subtraction Number * Multiplication Number / Floating point division Number bnot Unary bitwise NOT Integer div Integer division Integer rem Integer remainder of X/Y Integer band Bitwise AND Integer bor Bitwise OR Integer bxor Arithmetic bitwise XOR Integer bsl Arithmetic bit shift left Integer bsr Bit shift right Integer Boolean expressions. Operator Description not Unary logical NOT and Logical AND or Logical OR xor Logical XOR Short-circuit expressions andalso , orelse .","title":"Pattern and constraint expressions"},{"location":"using-detecter/the-specification-logic.html#a-simple-example","text":"Let us try to specify a safety requirement on the behaviour of our calculator program . The sHML formula with symbolic action Srv : Clt ! { bye , Tot } when Tot < 0 describes the property requiring that \u201cthe program state does not exhibit a send event whose payload consists of { bye , Tot } with a negative total: and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff Recall that the universal modality states that, for any program event satisfying the symbolic action P when C in [ P when C ] \u03c6 , the ensuing program behaviour must then satisfy the continuation formula \u03c6 . However, no program state can satisfy the continuation ff ! This means that the formula and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff can only be satisfied when our calculator program does not exhibit the event described by the symbolic action Srv : Clt ! { bye , Tot } when Tot < 0 . Suppose our server with PID < 0 . 10 . 0 > exhibits the send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , - 1 } in response to a request issued by a client with PID < 0 . 16 . 0 > . It matches pattern Srv : Clt ! { bye , Tot } , instantiating the variables Srv = < 0 . 10 . 0 > , Clt = < 0 . 16 . 0 > , and Tot = - 1 . The constraint when Tot < 0 is also satisfied by Tot , leading to a violation, i.e. , ff . For a different send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , 1 } , the symbolic action in the modality [ Srv : Clt ! { bye , Tot } when Tot < 0 ] is not satisfied, and consequently, and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff is not violated. Analogously, the exit event < 0 . 10 . 0 > ** killed does not lead to a violation of the formula since the pattern Srv : Clt ! { bye , Tot } fails to match the event shape. Cheat sheet The formula [ \u03b1 ] ff means that the program must not perform the symbolic action \u03b1 . Despite the fact that the runtime setting limits what one observes at runtime, we next outline how this does not prevent us from verifying properties expressed in sHML .","title":"A simple example"}]}