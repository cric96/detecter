{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"detectEr Tutorial Welcome to the detectEr tutorial! What is detectEr? detectEr is a runtime verification tool for asynchronous component systems. Detecter outline Publications List of publications. Our team The team. Help us Typos and bugs.","title":"Home"},{"location":"index.html#detecter-tutorial","text":"","title":"detectEr Tutorial"},{"location":"index.html#welcome-to-the-detecter-tutorial","text":"","title":"Welcome to the detectEr tutorial!"},{"location":"index.html#what-is-detecter","text":"detectEr is a runtime verification tool for asynchronous component systems. Detecter outline","title":"What is detectEr?"},{"location":"index.html#publications","text":"List of publications.","title":"Publications"},{"location":"index.html#our-team","text":"The team.","title":"Our team"},{"location":"index.html#help-us","text":"Typos and bugs.","title":"Help us"},{"location":"about.html","text":"Turba falsi florem Labentibus corpore nostra Lorem markdownum amplexa rector ora facies lumina sit lurida rursusque terruerat caelebs, diem. Contigit tortoque terebrata flore! daemon_soft_syn = e; overclocking = favicon; if (2 == windows(device, gifServer)) { primary *= botnetT; uncIntegrated(2 + ajax_trim_multiplatform, 664619 - internet_gigabyte_system, sampling_metal_copy); kindle = cronServerPpi; } boot_modem(1, onlineUtility, media - virtualization_trackball - macByteClip); Ab sonus: obruta nimium loco, bis nascendi nautae, solus cur ille turbamque damnatura turba madefactaque nescit Lacedaemoniumque . Ratibus iugulaberis, vetus ulla ubicumque opposui medicamina addita solacia iniusti amplexuque interque, admonitu nunc extendi sol. Nomina parentes potentum conplectitur socio, et dives adice et subit patriaeque crederet. Laesi saecula, dextrae; carpit dolos suspiria probro pendere simul hospita Gorgoneum. Accipe timeri nupsi fuit nostros quid memorem pellite metuunt: Harpalos positis plectrumque somno qui, ter falsa diversa motaque. Cum cum hic fugientibus vaccae de noluit sulphura cantu utque inmensi scopulum , vestra. Undis quotiens veteris nostro iube blanditiis nihil huc latus, igne inpune voluit, abiit, est Acmon viri. Exemplo capiebant o vocabula iusta; incubuitque interius ripas. Genitore sumptaque haud domos recens, pietas ille Zanclen secum; ferox ilice demittere cortice? Glomerari licet io protinus colubris vires egissem Margine de prisca fulvis miserae in illa claroque. Apolline auras ramum fitque quoque artifices oblivia nigraque freta croceum fauce et feres: nec pyra nec vertice: vincloque. Emittere dixit. Ut populis negarunt occuluit simili ne coepit Dianae quinquennia erat scrobe speciosam. Genitor qui terra mutasse nigro ! Glaebae stetit ab a arsit ignibus digna ulcisci repressit: opem arma petis, timendi hos omni et arma puerosque. Faciem conpleat mediis, Capitolia videndo ab aurumque, clamant et mihi bubo praebetis pater viscera deus. Sed pugman, nihil laudatve cervice videri. Alas oris Thetis est superis a picto nulla gente solebat a ossibus quoque! Et suis, quae Cyllenide imoque at, quisquis nulli, repetitum. Silvas est absens negata faciat iamque putant; re et, qua dixit. Excutis adsiduae Lyncides. Suis Sithon vocat pennis lupo fallitis potuit inrorant laetoque. Hic raptores possunt fatebor cornum usa.","title":"Turba falsi florem"},{"location":"about.html#turba-falsi-florem","text":"","title":"Turba falsi florem"},{"location":"about.html#labentibus-corpore-nostra","text":"Lorem markdownum amplexa rector ora facies lumina sit lurida rursusque terruerat caelebs, diem. Contigit tortoque terebrata flore! daemon_soft_syn = e; overclocking = favicon; if (2 == windows(device, gifServer)) { primary *= botnetT; uncIntegrated(2 + ajax_trim_multiplatform, 664619 - internet_gigabyte_system, sampling_metal_copy); kindle = cronServerPpi; } boot_modem(1, onlineUtility, media - virtualization_trackball - macByteClip); Ab sonus: obruta nimium loco, bis nascendi nautae, solus cur ille turbamque damnatura turba madefactaque nescit Lacedaemoniumque . Ratibus iugulaberis, vetus ulla ubicumque opposui medicamina addita solacia iniusti amplexuque interque, admonitu nunc extendi sol. Nomina parentes potentum conplectitur socio, et dives adice et subit patriaeque crederet. Laesi saecula, dextrae; carpit dolos suspiria probro pendere simul hospita Gorgoneum. Accipe timeri nupsi fuit nostros quid memorem pellite metuunt: Harpalos positis plectrumque somno qui, ter falsa diversa motaque. Cum cum hic fugientibus vaccae de noluit sulphura cantu utque inmensi scopulum , vestra. Undis quotiens veteris nostro iube blanditiis nihil huc latus, igne inpune voluit, abiit, est Acmon viri. Exemplo capiebant o vocabula iusta; incubuitque interius ripas. Genitore sumptaque haud domos recens, pietas ille Zanclen secum; ferox ilice demittere cortice?","title":"Labentibus corpore nostra"},{"location":"about.html#glomerari-licet-io-protinus-colubris-vires-egissem","text":"Margine de prisca fulvis miserae in illa claroque. Apolline auras ramum fitque quoque artifices oblivia nigraque freta croceum fauce et feres: nec pyra nec vertice: vincloque. Emittere dixit. Ut populis negarunt occuluit simili ne coepit Dianae quinquennia erat scrobe speciosam. Genitor qui terra mutasse nigro ! Glaebae stetit ab a arsit ignibus digna ulcisci repressit: opem arma petis, timendi hos omni et arma puerosque. Faciem conpleat mediis, Capitolia videndo ab aurumque, clamant et mihi bubo praebetis pater viscera deus. Sed pugman, nihil laudatve cervice videri. Alas oris Thetis est superis a picto nulla gente solebat a ossibus quoque! Et suis, quae Cyllenide imoque at, quisquis nulli, repetitum. Silvas est absens negata faciat iamque putant; re et, qua dixit. Excutis adsiduae Lyncides. Suis Sithon vocat pennis lupo fallitis potuit inrorant laetoque. Hic raptores possunt fatebor cornum usa.","title":"Glomerari licet io protinus colubris vires egissem"},{"location":"erlang.html","text":"This is a test with calc_server : loop (_) monitor and ([_ Launcher <- _ Server , calc_server : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B ] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). with 'Elixir.Demo.CalcServer' : loop (_) monitor and ([_ Launcher <- _ Server , 'Elixir.Demo.CalcServer' : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B and is_integer ( A )] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). 1 2 3 4 5 6 7 fun ( Var ) -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end The range () function is used to generate a sequence of numbers. Ctrl + Alt + Del Ctrl + V + Tab + Enter + Cmd Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Hello Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Unordered List Example : * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci The HTML specification is maintained by the W3C . Duncan \\[ \\operatorname{ker} f=\\{g\\in {\\color{sepia}{G}}:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"This is a test"},{"location":"erlang.html#this-is-a-test","text":"with calc_server : loop (_) monitor and ([_ Launcher <- _ Server , calc_server : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B ] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). with 'Elixir.Demo.CalcServer' : loop (_) monitor and ([_ Launcher <- _ Server , 'Elixir.Demo.CalcServer' : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B and is_integer ( A )] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). 1 2 3 4 5 6 7 fun ( Var ) -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end The range () function is used to generate a sequence of numbers. Ctrl + Alt + Del Ctrl + V + Tab + Enter + Cmd Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Hello Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Unordered List Example : * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci The HTML specification is maintained by the W3C . Duncan \\[ \\operatorname{ker} f=\\{g\\in {\\color{sepia}{G}}:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"This is a test"},{"location":"getting-started/preparation.html","text":"Preparation Prerequisites This tutorial assumes that users are running Ubuntu/Debian, macOS or Windows 10. Windows 10 users may either install the Windows Subsystem for Linux and follow the instructions given below for Ubuntu/Debian , or alternatively, configure Chocolatey and install the software packages mentioned via choco install . However, our instructions will not detail how detectEr is installed and used on Windows systems. Please install the software package management system available your particular operating system before proceeding with the rest of the guide. Operating System Package Manager Installation Ubuntu/Debian APT Not required, comes pre-bundled macOS Homebrew Follow the Homebrew guide for installation Windows 10 Chocolatey Follow the Chocolatey guide for installation Installing Erlang Erlang can be installed on multiple platforms by compiling it from source or downloading one of the pre-compiled distributions hosted on erlang-solutions.com . We however follow the simpler route and install Erlang using the package managers mentioned above. Ubuntu/Debian On Ubuntu and Debian, Erlang can be installed using APT . Add the Erlang Solutions repository: wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb sudo dpkg -i erlang-solutions_2.0_all.deb Refresh the package manager repository cache: sudo apt update . Install the entire Erlang/ OTP suite only: sudo apt install erlang . macOS macOS users can install the entire Erlang/ OTP suite using Homebrew by running: brew install erlang . Windows 10 Windows 10 users not using WSL can install the entire Erlang/ OTP suite using Chocolatey by running: choco install erlang . Others Refer to the Erlang Solutions guide for installing Erlang/ OTP on other operating systems. Quick check Confirm that Erlang/ OTP distribution has been successfully installed and that the system PATH variable is properly configured by typing erl --version . Installing Elixir Elixir runs on the Erlang virtual machine and uses the same OTP libraries. We already installed the Erlang ecosystem, and need only install the Elixir language libraries. Ubuntu/Debian On Ubuntu and Debian, Elixir can be installed via APT using: sudo apt-get install elixir . macOS macOS users can install Elixir using Homebrew by running: brew install elixir . Windows 10 Windows 10 users not using WSL can install Elixir using Chocolatey by running: choco install elixir . Others Refer to the Elixir Lang guide for installing Elixir on other operating systems. Quick check Confirm that Elixir has been successfully installed and that the system PATH variable is properly configured by typing elixir --version . Installing Python We also make use of Python 3, that can be installed as explained below. Ubuntu/Debian Most distributions of Ubuntu and Debian come with Python pre-installed. Check the version of Python available on your operating system by executing python --version . If the reported version is older than 3.7.x or Python is not installed, follow these steps. Refresh the package manager repository cache (if not already done): sudo apt update . Install Python 3: sudo apt install python3.9 . Install the Python package manager PIP : sudo apt install python3-pip . Install also the core development support tools: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev . macOS macOS comes pre-installed with Python 2.7, which is not the version we use in this tutorial. Install Python 3 via Homebrew by typing: brew install python3 . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Windows 10 Windows 10 users not using WSL can install Python 3 via Chocolatey by typing: choco install python . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Others Refer to the Real Python guide for installing Python 3 on other operating systems. Quick check Confirm that Python 3 has been successfully installed and that the system PATH variable is properly configured by typing python3 --version . Also check that PIP for Python 3 has been installed, pip3 --version . Installing the virtual environment management tool Virtualenv is a tool used to create isolated Python environments. The environment it creates has its own installation directory, and does not share libraries with other Virtualenv environments. Virtualenv can be installed via PIP : pip3 install virtualenv . Configuring Visual Studio Code Any plain text editor can be used, but for this tutorial we opt for Visual Studio Code that can be downloaded from https://code.visualstudio.com . It can also be installed using the respective operating system package manager. Ubuntu/Debian On Ubuntu and Debian, VS Code can be installed using APT . Install APT transport for downloading packages via HTTPS: sudo apt install apt-transport-https to check Import the Microsoft GPG key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository by typing: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/code stable main\" Refresh the package manager repository cache: sudo apt update . Install VS Code: sudo apt install code . macOS macOS users can install VS Code using Homebrew by running: brew install --cask visual-studio-code . Windows 10 Windows 10 users not using WSL can install VS Code using Chocolatey by running: choco install vscode . Others Refer to the Visual Studio Code guide for installing it on other operating systems. Adding extensions To enable syntax highlighting and language support for the languages used in this tutorial, VS Code can be configured with these extensions. Erlang . Elixir . Python . sHML syntax highlighting? Versions These distribution versions are used in this tutorial. Your installed versions need not exactly match, but we document these in case of any problems you might face when working through the tutorial later on. Name Version Erlang/ OTP 23.3.2 Elixir 1.11.4 Python 3.9.4 PIP 21.0.1 VS Code 1.56.0","title":"Perparation"},{"location":"getting-started/preparation.html#preparation","text":"","title":"Preparation"},{"location":"getting-started/preparation.html#prerequisites","text":"This tutorial assumes that users are running Ubuntu/Debian, macOS or Windows 10. Windows 10 users may either install the Windows Subsystem for Linux and follow the instructions given below for Ubuntu/Debian , or alternatively, configure Chocolatey and install the software packages mentioned via choco install . However, our instructions will not detail how detectEr is installed and used on Windows systems. Please install the software package management system available your particular operating system before proceeding with the rest of the guide. Operating System Package Manager Installation Ubuntu/Debian APT Not required, comes pre-bundled macOS Homebrew Follow the Homebrew guide for installation Windows 10 Chocolatey Follow the Chocolatey guide for installation","title":"Prerequisites"},{"location":"getting-started/preparation.html#installing-erlang","text":"Erlang can be installed on multiple platforms by compiling it from source or downloading one of the pre-compiled distributions hosted on erlang-solutions.com . We however follow the simpler route and install Erlang using the package managers mentioned above. Ubuntu/Debian On Ubuntu and Debian, Erlang can be installed using APT . Add the Erlang Solutions repository: wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb sudo dpkg -i erlang-solutions_2.0_all.deb Refresh the package manager repository cache: sudo apt update . Install the entire Erlang/ OTP suite only: sudo apt install erlang . macOS macOS users can install the entire Erlang/ OTP suite using Homebrew by running: brew install erlang . Windows 10 Windows 10 users not using WSL can install the entire Erlang/ OTP suite using Chocolatey by running: choco install erlang . Others Refer to the Erlang Solutions guide for installing Erlang/ OTP on other operating systems. Quick check Confirm that Erlang/ OTP distribution has been successfully installed and that the system PATH variable is properly configured by typing erl --version .","title":"Installing Erlang"},{"location":"getting-started/preparation.html#installing-elixir","text":"Elixir runs on the Erlang virtual machine and uses the same OTP libraries. We already installed the Erlang ecosystem, and need only install the Elixir language libraries. Ubuntu/Debian On Ubuntu and Debian, Elixir can be installed via APT using: sudo apt-get install elixir . macOS macOS users can install Elixir using Homebrew by running: brew install elixir . Windows 10 Windows 10 users not using WSL can install Elixir using Chocolatey by running: choco install elixir . Others Refer to the Elixir Lang guide for installing Elixir on other operating systems. Quick check Confirm that Elixir has been successfully installed and that the system PATH variable is properly configured by typing elixir --version .","title":"Installing Elixir"},{"location":"getting-started/preparation.html#installing-python","text":"We also make use of Python 3, that can be installed as explained below. Ubuntu/Debian Most distributions of Ubuntu and Debian come with Python pre-installed. Check the version of Python available on your operating system by executing python --version . If the reported version is older than 3.7.x or Python is not installed, follow these steps. Refresh the package manager repository cache (if not already done): sudo apt update . Install Python 3: sudo apt install python3.9 . Install the Python package manager PIP : sudo apt install python3-pip . Install also the core development support tools: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev . macOS macOS comes pre-installed with Python 2.7, which is not the version we use in this tutorial. Install Python 3 via Homebrew by typing: brew install python3 . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Windows 10 Windows 10 users not using WSL can install Python 3 via Chocolatey by typing: choco install python . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Others Refer to the Real Python guide for installing Python 3 on other operating systems. Quick check Confirm that Python 3 has been successfully installed and that the system PATH variable is properly configured by typing python3 --version . Also check that PIP for Python 3 has been installed, pip3 --version .","title":"Installing Python"},{"location":"getting-started/preparation.html#installing-the-virtual-environment-management-tool","text":"Virtualenv is a tool used to create isolated Python environments. The environment it creates has its own installation directory, and does not share libraries with other Virtualenv environments. Virtualenv can be installed via PIP : pip3 install virtualenv .","title":"Installing the virtual environment management tool"},{"location":"getting-started/preparation.html#configuring-visual-studio-code","text":"Any plain text editor can be used, but for this tutorial we opt for Visual Studio Code that can be downloaded from https://code.visualstudio.com . It can also be installed using the respective operating system package manager. Ubuntu/Debian On Ubuntu and Debian, VS Code can be installed using APT . Install APT transport for downloading packages via HTTPS: sudo apt install apt-transport-https to check Import the Microsoft GPG key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository by typing: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/code stable main\" Refresh the package manager repository cache: sudo apt update . Install VS Code: sudo apt install code . macOS macOS users can install VS Code using Homebrew by running: brew install --cask visual-studio-code . Windows 10 Windows 10 users not using WSL can install VS Code using Chocolatey by running: choco install vscode . Others Refer to the Visual Studio Code guide for installing it on other operating systems.","title":"Configuring Visual Studio Code"},{"location":"getting-started/preparation.html#adding-extensions","text":"To enable syntax highlighting and language support for the languages used in this tutorial, VS Code can be configured with these extensions. Erlang . Elixir . Python . sHML syntax highlighting? Versions These distribution versions are used in this tutorial. Your installed versions need not exactly match, but we document these in case of any problems you might face when working through the tutorial later on. Name Version Erlang/ OTP 23.3.2 Elixir 1.11.4 Python 3.9.4 PIP 21.0.1 VS Code 1.56.0","title":"Adding extensions"},{"location":"getting-started/quickstart.html","text":"Quickstart Using detectEr from the shell The detecter/ebin directory created previously needs to be included in the Erlang runtime path to preload all the binaries required to be able to use detectEr. This is done by using the -pa switch when launching the Erlang shell. erl -pa /path/to/detecter/ebin Once loaded, detectEr can be used to monitor any system that executes on the Erlang Virtual Machine. It also supports the monitoring of systems that run outside of the EVM , providing these record their logs in files whose every log entry follows a predetermined formatting that enables detectEr to extract runtime information. This topic is covered in more depth in the Instrumentation section. For now, we establish the workflow required to use detectEr by way of the traditional hello world example. Hello world Before using detectEr, you should get an intuitive grasp of what monitoring involves, and the steps one needs to follow to initialise and start the monitoring process. This also helps you to get acquainted with the Erlang shell if this is your first time using Erlang. Launch a new terminal emulator window ( e.g. Terminal Ubuntu or macOS), navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. [duncan@local]:/detecter/examples/erlang$ make rm -f ebin/*.beam ebin/*.E ebin/*.tmp erl_crash.dump ebin/*.app ... [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 7 duncan duncan 224 May 17 17:16 ebin drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src 3. Launch the Erlang shell erl . We add the binaries of the ebin directory to the Erlang code path via the -pa flag to load and make them accessible from the shell. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> 4. The Erlang shell allows you to type expressions and execute them by pressing Enter . Every expression typed on the shell must be terminated with a full-stop. Try invoking the function greet of the hello module. The function greet accepts one argument, the name of the person to greet, specified as a list of characters or directly as a string enclosed within double quotes. 1 > hello : greet ( \"Duncan\" ). Hello there , Duncan ! ok 2 > 5. Quit the Erlang shell by typing q(). Function signatures In Erlang (and Elixir), functions are uniquely identified via the triple mod : fun / arity , where mod is the module name, fun , the name of the function contained in the module, and arity , the number of arguments that the function accepts. For example, our greet function inside the module hello can be concisely referred to as hello : greet / 1 . Hello world, the asynchronous way You might have noticed that hello : greet / 1 pauses the Erlang shell momentarily before the greeting is displayed. During this interval, the shell is inoperable and cannot accept user input. Such function calls are called synchronous invocations, since they block the caller until the called function returns, i.e. the body of the called function is executed in its entirety and a value is returned to the caller. Examining the body of greet makes it clear why the Erlang shell stops responding when the function call is effected. 1 2 3 greet ( Name ) -> timer : sleep ( 5000 ), % Pause for 5 seconds to simulate some work.. io : format ( \"Hello there, ~s ! ~n \" , [ Name ]). Line 1 defines the function greet that accepts Name as parameter, while line 3 prints the greeting on the Erlang shell via call to io : format / 2 . The call timer : sleep ( 5000 ) on line 2 pauses the caller process ( i.e. the Erlang shell, in this case) to wait for 5000 ms before executing the rest of the function body. In Erlang, the function return value is the result of the last expression in the function, in this instance, the atom ok returned by io : format / 2 . Synchronous calls Synchronous function calls are useful when one needs to ensure that certain processes execute in some prescribed order with respect to one another, e.g. in lock step. This mode of interaction is common to many standard communication protocols such as HTTP , SMTP , DNS , etc. Unwanted synchrony can be easily avoided by launching functions to execute as independent processes that run concurrently with other processes in the system. To this end, Erlang provides the Built-in Functions spawn / { 1 - 4 } and their variations. Our hello world example is slightly tweaked to spawn hello : greet / 1 as a separate process that executes concurrently with the Erlang shell process. The function hello : start_greet / 1 implements this modification. It uses the BIF spawn / 3 (line 2 ) to launch the hello : greet / 1 function as a new process, returning the ID of the new process. The Process ID (also called the PID ) is a triple that uniquely identifies an Erlang process executing on the EVM . Function start_greet makes use of the predefined macro ? MODULE , that gets replaced with the name of the module it appears in when the source code of the hello module is preprocessed by the Erlang compiler. Concretely, the invocation to spawn/3 on line 5 yields the source code spawn ( hello , greet , [ Name ]) prior to compilation. 4 5 start_greet ( Name ) when is_list ( Name ) -> spawn ( ? MODULE , greet , [ Name ]). Restart the Erlang shell and invoke hello : start_greet / 1 . 1 > hello : start_greet ( \"Duncan\" ). < 0 . 84 . 0 > Hello there , Duncan ! % Shown after a slight pause. 2 > Observe that now: The return value of start_greet is the PID <0.84.0> , not the atom ok ; The Erlang shell does not block but returns immediately; After the predefined sleep time elapses, the greeting is printed to the shell. Asynchronous runtime monitoring In this quickstart demo, we monitor the execution of our asynchronous hello world example. 2. Start shell: erl -pa ebin -pa ../../detecter/ebin 3. Compile analyzer: hml_eval:compile(\"props/hello_prop.hml\", [{outdir,\"ebin\"}, v]). 4. hello_prop:mfa_spec({hello, greet, [\"Duncan\"]}). 4. monitor:start_online({hello,start_greet, [\"Duncan\"]}, fun hello_prop:mfa_spec/1, []). Follow these steps to test the first The instructions also For now, you can follow these instructions; we elaborate further on what each step entails and the different options detectEr provides when it comes to monitoring. Consider the very simple system consisting of a process that forks a second process which prints Hello, involves, and what steps one needs to execute to start the monitoring process. Before using detecter You can familiarise yourself with the detecter There are a number of steps involved Navigate to the detecter/examples directory Using the Erlang shell Using the Elixir shell Using the Python shell DetectER The outer make file. Compiling the simple system of Erlang Compiling a simple monitor Instrumenting it and we see some verdict.","title":"Quickstart"},{"location":"getting-started/quickstart.html#quickstart","text":"","title":"Quickstart"},{"location":"getting-started/quickstart.html#using-detecter-from-the-shell","text":"The detecter/ebin directory created previously needs to be included in the Erlang runtime path to preload all the binaries required to be able to use detectEr. This is done by using the -pa switch when launching the Erlang shell. erl -pa /path/to/detecter/ebin Once loaded, detectEr can be used to monitor any system that executes on the Erlang Virtual Machine. It also supports the monitoring of systems that run outside of the EVM , providing these record their logs in files whose every log entry follows a predetermined formatting that enables detectEr to extract runtime information. This topic is covered in more depth in the Instrumentation section. For now, we establish the workflow required to use detectEr by way of the traditional hello world example.","title":"Using detectEr from the shell"},{"location":"getting-started/quickstart.html#hello-world","text":"Before using detectEr, you should get an intuitive grasp of what monitoring involves, and the steps one needs to follow to initialise and start the monitoring process. This also helps you to get acquainted with the Erlang shell if this is your first time using Erlang. Launch a new terminal emulator window ( e.g. Terminal Ubuntu or macOS), navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. [duncan@local]:/detecter/examples/erlang$ make rm -f ebin/*.beam ebin/*.E ebin/*.tmp erl_crash.dump ebin/*.app ... [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 7 duncan duncan 224 May 17 17:16 ebin drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src 3. Launch the Erlang shell erl . We add the binaries of the ebin directory to the Erlang code path via the -pa flag to load and make them accessible from the shell. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> 4. The Erlang shell allows you to type expressions and execute them by pressing Enter . Every expression typed on the shell must be terminated with a full-stop. Try invoking the function greet of the hello module. The function greet accepts one argument, the name of the person to greet, specified as a list of characters or directly as a string enclosed within double quotes. 1 > hello : greet ( \"Duncan\" ). Hello there , Duncan ! ok 2 > 5. Quit the Erlang shell by typing q(). Function signatures In Erlang (and Elixir), functions are uniquely identified via the triple mod : fun / arity , where mod is the module name, fun , the name of the function contained in the module, and arity , the number of arguments that the function accepts. For example, our greet function inside the module hello can be concisely referred to as hello : greet / 1 .","title":"Hello world"},{"location":"getting-started/quickstart.html#hello-world-the-asynchronous-way","text":"You might have noticed that hello : greet / 1 pauses the Erlang shell momentarily before the greeting is displayed. During this interval, the shell is inoperable and cannot accept user input. Such function calls are called synchronous invocations, since they block the caller until the called function returns, i.e. the body of the called function is executed in its entirety and a value is returned to the caller. Examining the body of greet makes it clear why the Erlang shell stops responding when the function call is effected. 1 2 3 greet ( Name ) -> timer : sleep ( 5000 ), % Pause for 5 seconds to simulate some work.. io : format ( \"Hello there, ~s ! ~n \" , [ Name ]). Line 1 defines the function greet that accepts Name as parameter, while line 3 prints the greeting on the Erlang shell via call to io : format / 2 . The call timer : sleep ( 5000 ) on line 2 pauses the caller process ( i.e. the Erlang shell, in this case) to wait for 5000 ms before executing the rest of the function body. In Erlang, the function return value is the result of the last expression in the function, in this instance, the atom ok returned by io : format / 2 . Synchronous calls Synchronous function calls are useful when one needs to ensure that certain processes execute in some prescribed order with respect to one another, e.g. in lock step. This mode of interaction is common to many standard communication protocols such as HTTP , SMTP , DNS , etc. Unwanted synchrony can be easily avoided by launching functions to execute as independent processes that run concurrently with other processes in the system. To this end, Erlang provides the Built-in Functions spawn / { 1 - 4 } and their variations. Our hello world example is slightly tweaked to spawn hello : greet / 1 as a separate process that executes concurrently with the Erlang shell process. The function hello : start_greet / 1 implements this modification. It uses the BIF spawn / 3 (line 2 ) to launch the hello : greet / 1 function as a new process, returning the ID of the new process. The Process ID (also called the PID ) is a triple that uniquely identifies an Erlang process executing on the EVM . Function start_greet makes use of the predefined macro ? MODULE , that gets replaced with the name of the module it appears in when the source code of the hello module is preprocessed by the Erlang compiler. Concretely, the invocation to spawn/3 on line 5 yields the source code spawn ( hello , greet , [ Name ]) prior to compilation. 4 5 start_greet ( Name ) when is_list ( Name ) -> spawn ( ? MODULE , greet , [ Name ]). Restart the Erlang shell and invoke hello : start_greet / 1 . 1 > hello : start_greet ( \"Duncan\" ). < 0 . 84 . 0 > Hello there , Duncan ! % Shown after a slight pause. 2 > Observe that now: The return value of start_greet is the PID <0.84.0> , not the atom ok ; The Erlang shell does not block but returns immediately; After the predefined sleep time elapses, the greeting is printed to the shell.","title":"Hello world, the asynchronous way"},{"location":"getting-started/quickstart.html#asynchronous-runtime-monitoring","text":"In this quickstart demo, we monitor the execution of our asynchronous hello world example.","title":"Asynchronous runtime monitoring"},{"location":"getting-started/quickstart.html#2-start-shell-erl-pa-ebin-pa-detecterebin","text":"","title":"2. Start shell: erl -pa ebin -pa ../../detecter/ebin"},{"location":"getting-started/quickstart.html#3-compile-analyzer-hml_evalcompilepropshello_prophml-outdirebin-v","text":"","title":"3. Compile analyzer: hml_eval:compile(\"props/hello_prop.hml\", [{outdir,\"ebin\"}, v])."},{"location":"getting-started/quickstart.html#4-hello_propmfa_spechello-greet-duncan","text":"","title":"4. hello_prop:mfa_spec({hello, greet, [\"Duncan\"]})."},{"location":"getting-started/quickstart.html#4-monitorstart_onlinehellostart_greet-duncan-fun-hello_propmfa_spec1","text":"Follow these steps to test the first The instructions also For now, you can follow these instructions; we elaborate further on what each step entails and the different options detectEr provides when it comes to monitoring. Consider the very simple system consisting of a process that forks a second process which prints Hello, involves, and what steps one needs to execute to start the monitoring process. Before using detecter You can familiarise yourself with the detecter There are a number of steps involved Navigate to the detecter/examples directory Using the Erlang shell Using the Elixir shell Using the Python shell DetectER The outer make file. Compiling the simple system of Erlang Compiling a simple monitor Instrumenting it and we see some verdict.","title":"4. monitor:start_online({hello,start_greet, [\"Duncan\"]}, fun hello_prop:mfa_spec/1, [])."},{"location":"getting-started/setting-up-detecter.html","text":"Setting up detectEr Downloading detectEr detectEr can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling detectEr examples Tutorial examples erlang Calculator server implementation in Erlang src Erlang module sources props sHML property specifications Makefile Makefile with targets for compiling the example elixir Calculator server implementation in Elixir lib Elixir module sources props sHML property specifications Makefile Makefile with targets for compiling the example python Calculator server implementation in Python using TCP sockets src Python script sources props sHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license Compiling detectEr For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules in *.beam representation. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr","title":"Setting up detectEr"},{"location":"getting-started/setting-up-detecter.html#setting-up-detecter","text":"","title":"Setting up detectEr"},{"location":"getting-started/setting-up-detecter.html#downloading-detecter","text":"detectEr can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling detectEr examples Tutorial examples erlang Calculator server implementation in Erlang src Erlang module sources props sHML property specifications Makefile Makefile with targets for compiling the example elixir Calculator server implementation in Elixir lib Elixir module sources props sHML property specifications Makefile Makefile with targets for compiling the example python Calculator server implementation in Python using TCP sockets src Python script sources props sHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license","title":"Downloading detectEr"},{"location":"getting-started/setting-up-detecter.html#compiling-detecter","text":"For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules in *.beam representation. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr","title":"Compiling detectEr"},{"location":"using-detecter/instrumentation.html","text":"Diagram of the system architecture. How the same generated analyzer code is used to instrument the Erlang, Elixir and Python setups.","title":"Instrumentation"},{"location":"using-detecter/properties.html","text":"Synthesis The property of request count, but instead of the exit event use the init event of the process. Specify a simple property and explain the synthesised code, giving an example of how the events are consumed and processed.","title":"Synthesis"},{"location":"using-detecter/properties.html#synthesis","text":"The property of request count, but instead of the exit event use the init event of the process. Specify a simple property and explain the synthesised code, giving an example of how the events are consumed and processed.","title":"Synthesis"},{"location":"using-detecter/the-specification-logic.html","text":"The Specification Logic Discuss the four constructs of the logic. EG: Simple necessities. Discuss the constraint language and insert a table of all the operators it supports. Discuss the properties in the paper and explain how these are expressed in the logic SHML.","title":"The Specification Logic"},{"location":"using-detecter/the-specification-logic.html#the-specification-logic","text":"Discuss the four constructs of the logic. EG: Simple necessities. Discuss the constraint language and insert a table of all the operators it supports. Discuss the properties in the paper and explain how these are expressed in the logic SHML.","title":"The Specification Logic"}]}