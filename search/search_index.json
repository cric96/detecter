{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the detectEr tutorial! \u00b6 What is detectEr? \u00b6 detectEr is a runtime verification tool for asynchronous component systems. It is the product of five years of theoretical and practical development. Publications \u00b6 List of publications. Our group \u00b6 detectEr is part of the TheoFoMon and MoVeMnt projects funded by the Icelandic Research Fund . Duncan Paul Attard\u2014the principal developer of the detectEr\u2014has worked as a software developer in the Telecoms and Online payment industry for seven years prior to joining the academia. Help us \u00b6 Please help us improve this tutorial and the tool detectEr! We would appreciate if any typos or bugs found are reported on the issues page on GitHub.","title":"Home"},{"location":"index.html#welcome-to-the-detecter-tutorial","text":"","title":"Welcome to the detectEr tutorial!"},{"location":"index.html#what-is-detecter","text":"detectEr is a runtime verification tool for asynchronous component systems. It is the product of five years of theoretical and practical development.","title":"What is detectEr?"},{"location":"index.html#publications","text":"List of publications.","title":"Publications"},{"location":"index.html#our-group","text":"detectEr is part of the TheoFoMon and MoVeMnt projects funded by the Icelandic Research Fund . Duncan Paul Attard\u2014the principal developer of the detectEr\u2014has worked as a software developer in the Telecoms and Online payment industry for seven years prior to joining the academia.","title":"Our group"},{"location":"index.html#help-us","text":"Please help us improve this tutorial and the tool detectEr! We would appreciate if any typos or bugs found are reported on the issues page on GitHub.","title":"Help us"},{"location":"about.html","text":"Turba falsi florem \u00b6 Labentibus corpore nostra \u00b6 Lorem markdownum amplexa rector ora facies lumina sit lurida rursusque terruerat caelebs, diem. Contigit tortoque terebrata flore! daemon_soft_syn = e; overclocking = favicon; if (2 == windows(device, gifServer)) { primary *= botnetT; uncIntegrated(2 + ajax_trim_multiplatform, 664619 - internet_gigabyte_system, sampling_metal_copy); kindle = cronServerPpi; } boot_modem(1, onlineUtility, media - virtualization_trackball - macByteClip); Ab sonus: obruta nimium loco, bis nascendi nautae, solus cur ille turbamque damnatura turba madefactaque nescit Lacedaemoniumque . Ratibus iugulaberis, vetus ulla ubicumque opposui medicamina addita solacia iniusti amplexuque interque, admonitu nunc extendi sol. Nomina parentes potentum conplectitur socio, et dives adice et subit patriaeque crederet. Laesi saecula, dextrae; carpit dolos suspiria probro pendere simul hospita Gorgoneum. Accipe timeri nupsi fuit nostros quid memorem pellite metuunt: Harpalos positis plectrumque somno qui, ter falsa diversa motaque. Cum cum hic fugientibus vaccae de noluit sulphura cantu utque inmensi scopulum , vestra. Undis quotiens veteris nostro iube blanditiis nihil huc latus, igne inpune voluit, abiit, est Acmon viri. Exemplo capiebant o vocabula iusta; incubuitque interius ripas. Genitore sumptaque haud domos recens, pietas ille Zanclen secum; ferox ilice demittere cortice? Glomerari licet io protinus colubris vires egissem \u00b6 Margine de prisca fulvis miserae in illa claroque. Apolline auras ramum fitque quoque artifices oblivia nigraque freta croceum fauce et feres: nec pyra nec vertice: vincloque. Emittere dixit. Ut populis negarunt occuluit simili ne coepit Dianae quinquennia erat scrobe speciosam. Genitor qui terra mutasse nigro ! Glaebae stetit ab a arsit ignibus digna ulcisci repressit: opem arma petis, timendi hos omni et arma puerosque. Faciem conpleat mediis, Capitolia videndo ab aurumque, clamant et mihi bubo praebetis pater viscera deus. Sed pugman, nihil laudatve cervice videri. Alas oris Thetis est superis a picto nulla gente solebat a ossibus quoque! Et suis, quae Cyllenide imoque at, quisquis nulli, repetitum. Silvas est absens negata faciat iamque putant; re et, qua dixit. Excutis adsiduae Lyncides. Suis Sithon vocat pennis lupo fallitis potuit inrorant laetoque. Hic raptores possunt fatebor cornum usa.","title":"Turba falsi florem"},{"location":"about.html#turba-falsi-florem","text":"","title":"Turba falsi florem"},{"location":"about.html#labentibus-corpore-nostra","text":"Lorem markdownum amplexa rector ora facies lumina sit lurida rursusque terruerat caelebs, diem. Contigit tortoque terebrata flore! daemon_soft_syn = e; overclocking = favicon; if (2 == windows(device, gifServer)) { primary *= botnetT; uncIntegrated(2 + ajax_trim_multiplatform, 664619 - internet_gigabyte_system, sampling_metal_copy); kindle = cronServerPpi; } boot_modem(1, onlineUtility, media - virtualization_trackball - macByteClip); Ab sonus: obruta nimium loco, bis nascendi nautae, solus cur ille turbamque damnatura turba madefactaque nescit Lacedaemoniumque . Ratibus iugulaberis, vetus ulla ubicumque opposui medicamina addita solacia iniusti amplexuque interque, admonitu nunc extendi sol. Nomina parentes potentum conplectitur socio, et dives adice et subit patriaeque crederet. Laesi saecula, dextrae; carpit dolos suspiria probro pendere simul hospita Gorgoneum. Accipe timeri nupsi fuit nostros quid memorem pellite metuunt: Harpalos positis plectrumque somno qui, ter falsa diversa motaque. Cum cum hic fugientibus vaccae de noluit sulphura cantu utque inmensi scopulum , vestra. Undis quotiens veteris nostro iube blanditiis nihil huc latus, igne inpune voluit, abiit, est Acmon viri. Exemplo capiebant o vocabula iusta; incubuitque interius ripas. Genitore sumptaque haud domos recens, pietas ille Zanclen secum; ferox ilice demittere cortice?","title":"Labentibus corpore nostra"},{"location":"about.html#glomerari-licet-io-protinus-colubris-vires-egissem","text":"Margine de prisca fulvis miserae in illa claroque. Apolline auras ramum fitque quoque artifices oblivia nigraque freta croceum fauce et feres: nec pyra nec vertice: vincloque. Emittere dixit. Ut populis negarunt occuluit simili ne coepit Dianae quinquennia erat scrobe speciosam. Genitor qui terra mutasse nigro ! Glaebae stetit ab a arsit ignibus digna ulcisci repressit: opem arma petis, timendi hos omni et arma puerosque. Faciem conpleat mediis, Capitolia videndo ab aurumque, clamant et mihi bubo praebetis pater viscera deus. Sed pugman, nihil laudatve cervice videri. Alas oris Thetis est superis a picto nulla gente solebat a ossibus quoque! Et suis, quae Cyllenide imoque at, quisquis nulli, repetitum. Silvas est absens negata faciat iamque putant; re et, qua dixit. Excutis adsiduae Lyncides. Suis Sithon vocat pennis lupo fallitis potuit inrorant laetoque. Hic raptores possunt fatebor cornum usa.","title":"Glomerari licet io protinus colubris vires egissem"},{"location":"erlang.html","text":"This is a test \u00b6 with calc_server : loop (_) monitor and ([_ Launcher <- _ Server , calc_server : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B ] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). with 'Elixir.Demo.CalcServer' : loop (_) monitor and ([_ Launcher <- _ Server , 'Elixir.Demo.CalcServer' : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B and is_integer ( A )] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). 1 2 3 4 5 6 7 fun ( Var ) -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end The range () function is used to generate a sequence of numbers. Ctrl + Alt + Del Ctrl + V + Tab + Enter + Cmd Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Hello Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Unordered List Example : * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci The HTML specification is maintained by the W3C . Duncan \\[ \\operatorname{ker} f=\\{g\\in {\\color{sepia}{G}}:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"This is a test"},{"location":"erlang.html#this-is-a-test","text":"with calc_server : loop (_) monitor and ([_ Launcher <- _ Server , calc_server : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B ] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). with 'Elixir.Demo.CalcServer' : loop (_) monitor and ([_ Launcher <- _ Server , 'Elixir.Demo.CalcServer' : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B and is_integer ( A )] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). 1 2 3 4 5 6 7 fun ( Var ) -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end The range () function is used to generate a sequence of numbers. Ctrl + Alt + Del Ctrl + V + Tab + Enter + Cmd Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Hello Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Unordered List Example : * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci The HTML specification is maintained by the W3C . Duncan \\[ \\operatorname{ker} f=\\{g\\in {\\color{sepia}{G}}:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"This is a test"},{"location":"getting-started/preparation.html","text":"Preparation \u00b6 Prerequisites \u00b6 This tutorial assumes that users are running Ubuntu/Debian, macOS or Windows 10. Windows 10 users may either install the Windows Subsystem for Linux and follow the instructions given below for Ubuntu/Debian , or alternatively, configure Chocolatey and install the software packages mentioned via choco install . However, our instructions will not detail how detectEr is installed and used on Windows systems. Please install the software package management system available for your particular operating system before proceeding with the rest of the guide. Operating System Package Manager Installation Ubuntu/Debian APT Not required, comes pre-bundled macOS Homebrew Follow the Homebrew guide for installation Windows 10 Chocolatey Follow the Chocolatey guide for installation Installing Erlang \u00b6 Erlang can be installed on multiple platforms by compiling it from source or downloading one of the pre-compiled distributions hosted on erlang-solutions.com . We however follow the simpler route and install Erlang using the package managers mentioned above. Ubuntu/Debian On Ubuntu and Debian, Erlang can be installed using APT . Add the Erlang Solutions repository: wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb sudo dpkg -i erlang-solutions_2.0_all.deb Refresh the package manager repository cache: sudo apt update . Install the entire Erlang/ OTP suite only: sudo apt install erlang . macOS macOS users can install the entire Erlang/ OTP suite using Homebrew by running: brew install erlang . Windows 10 Windows 10 users not using WSL can install the entire Erlang/ OTP suite using Chocolatey by running: choco install erlang . Others Refer to the Erlang Solutions guide for installing Erlang/ OTP on other operating systems. Quick check Confirm that Erlang/ OTP distribution has been successfully installed and that the system PATH variable is properly configured by typing erl --version . Installing Elixir \u00b6 Elixir runs on the Erlang virtual machine and uses the same OTP libraries. We already installed the Erlang ecosystem, and need only install the Elixir language libraries. Ubuntu/Debian On Ubuntu and Debian, Elixir can be installed via APT using: sudo apt-get install elixir . macOS macOS users can install Elixir using Homebrew by running: brew install elixir . Windows 10 Windows 10 users not using WSL can install Elixir using Chocolatey by running: choco install elixir . Others Refer to the Elixir Lang guide for installing Elixir on other operating systems. Quick check Confirm that Elixir has been successfully installed and that the system PATH variable is properly configured by typing elixir --version . Installing Python \u00b6 We also make use of Python 3, that can be installed as explained below. Ubuntu/Debian Most distributions of Ubuntu and Debian come with Python pre-installed. Check the version of Python available on your operating system by executing python --version . If the reported version is older than 3.7.x or Python is not installed, follow these steps. Refresh the package manager repository cache (if not already done): sudo apt update . Install Python 3: sudo apt install python3.9 . Install the Python package manager PIP : sudo apt install python3-pip . Also install the core development support tools: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev . macOS macOS comes pre-installed with Python 2.7, which is not the version we use in this tutorial. Install Python 3 via Homebrew by typing: brew install python3 . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Windows 10 Windows 10 users not using WSL can install Python 3 via Chocolatey by typing: choco install python . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Others Refer to the Real Python guide for installing Python 3 on other operating systems. Quick check Confirm that Python 3 has been successfully installed and that the system PATH variable is properly configured by typing python3 --version . Also check that PIP for Python 3 has been installed, pip3 --version . Installing the virtual environment management tool \u00b6 Virtualenv is a tool used to create isolated Python environments. The environment it creates has its own installation directory, and does not share libraries with other Virtualenv environments. Virtualenv can be installed via PIP : pip3 install virtualenv . Configuring Visual Studio Code \u00b6 Any plain text editor can be used, but for this tutorial we opt for Visual Studio Code that can be downloaded from https://code.visualstudio.com . It can also be installed using the respective operating system package manager. Ubuntu/Debian On Ubuntu and Debian, VS Code can be installed using APT . Install APT transport for downloading packages via HTTPS: sudo apt install apt-transport-https to check Import the Microsoft GPG key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository by typing: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/code stable main\" Refresh the package manager repository cache: sudo apt update . Install VS Code: sudo apt install code . macOS macOS users can install VS Code using Homebrew by running: brew install --cask visual-studio-code . Windows 10 Windows 10 users not using WSL can install VS Code using Chocolatey by running: choco install vscode . Others Refer to the Visual Studio Code guide for installing it on other operating systems. Adding extensions \u00b6 To enable syntax highlighting and language support for the languages used in this tutorial, VS Code can be configured with these extensions. Erlang . Elixir . Python . sHML syntax highlighting? Versions These distribution versions are used in this tutorial. Your installed versions need not exactly match, but we document these in case of any problems you might face when working through the tutorial later on. Name Version Erlang/ OTP 23.3.2 Elixir 1.11.4 Python 3.9.4 PIP 21.0.1 VS Code 1.56.0 LINK TO NEXT SECTION","title":"Preparation"},{"location":"getting-started/preparation.html#preparation","text":"","title":"Preparation"},{"location":"getting-started/preparation.html#prerequisites","text":"This tutorial assumes that users are running Ubuntu/Debian, macOS or Windows 10. Windows 10 users may either install the Windows Subsystem for Linux and follow the instructions given below for Ubuntu/Debian , or alternatively, configure Chocolatey and install the software packages mentioned via choco install . However, our instructions will not detail how detectEr is installed and used on Windows systems. Please install the software package management system available for your particular operating system before proceeding with the rest of the guide. Operating System Package Manager Installation Ubuntu/Debian APT Not required, comes pre-bundled macOS Homebrew Follow the Homebrew guide for installation Windows 10 Chocolatey Follow the Chocolatey guide for installation","title":"Prerequisites"},{"location":"getting-started/preparation.html#installing-erlang","text":"Erlang can be installed on multiple platforms by compiling it from source or downloading one of the pre-compiled distributions hosted on erlang-solutions.com . We however follow the simpler route and install Erlang using the package managers mentioned above. Ubuntu/Debian On Ubuntu and Debian, Erlang can be installed using APT . Add the Erlang Solutions repository: wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb sudo dpkg -i erlang-solutions_2.0_all.deb Refresh the package manager repository cache: sudo apt update . Install the entire Erlang/ OTP suite only: sudo apt install erlang . macOS macOS users can install the entire Erlang/ OTP suite using Homebrew by running: brew install erlang . Windows 10 Windows 10 users not using WSL can install the entire Erlang/ OTP suite using Chocolatey by running: choco install erlang . Others Refer to the Erlang Solutions guide for installing Erlang/ OTP on other operating systems. Quick check Confirm that Erlang/ OTP distribution has been successfully installed and that the system PATH variable is properly configured by typing erl --version .","title":"Installing Erlang"},{"location":"getting-started/preparation.html#installing-elixir","text":"Elixir runs on the Erlang virtual machine and uses the same OTP libraries. We already installed the Erlang ecosystem, and need only install the Elixir language libraries. Ubuntu/Debian On Ubuntu and Debian, Elixir can be installed via APT using: sudo apt-get install elixir . macOS macOS users can install Elixir using Homebrew by running: brew install elixir . Windows 10 Windows 10 users not using WSL can install Elixir using Chocolatey by running: choco install elixir . Others Refer to the Elixir Lang guide for installing Elixir on other operating systems. Quick check Confirm that Elixir has been successfully installed and that the system PATH variable is properly configured by typing elixir --version .","title":"Installing Elixir"},{"location":"getting-started/preparation.html#installing-python","text":"We also make use of Python 3, that can be installed as explained below. Ubuntu/Debian Most distributions of Ubuntu and Debian come with Python pre-installed. Check the version of Python available on your operating system by executing python --version . If the reported version is older than 3.7.x or Python is not installed, follow these steps. Refresh the package manager repository cache (if not already done): sudo apt update . Install Python 3: sudo apt install python3.9 . Install the Python package manager PIP : sudo apt install python3-pip . Also install the core development support tools: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev . macOS macOS comes pre-installed with Python 2.7, which is not the version we use in this tutorial. Install Python 3 via Homebrew by typing: brew install python3 . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Windows 10 Windows 10 users not using WSL can install Python 3 via Chocolatey by typing: choco install python . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Others Refer to the Real Python guide for installing Python 3 on other operating systems. Quick check Confirm that Python 3 has been successfully installed and that the system PATH variable is properly configured by typing python3 --version . Also check that PIP for Python 3 has been installed, pip3 --version .","title":"Installing Python"},{"location":"getting-started/preparation.html#installing-the-virtual-environment-management-tool","text":"Virtualenv is a tool used to create isolated Python environments. The environment it creates has its own installation directory, and does not share libraries with other Virtualenv environments. Virtualenv can be installed via PIP : pip3 install virtualenv .","title":"Installing the virtual environment management tool"},{"location":"getting-started/preparation.html#configuring-visual-studio-code","text":"Any plain text editor can be used, but for this tutorial we opt for Visual Studio Code that can be downloaded from https://code.visualstudio.com . It can also be installed using the respective operating system package manager. Ubuntu/Debian On Ubuntu and Debian, VS Code can be installed using APT . Install APT transport for downloading packages via HTTPS: sudo apt install apt-transport-https to check Import the Microsoft GPG key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository by typing: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/code stable main\" Refresh the package manager repository cache: sudo apt update . Install VS Code: sudo apt install code . macOS macOS users can install VS Code using Homebrew by running: brew install --cask visual-studio-code . Windows 10 Windows 10 users not using WSL can install VS Code using Chocolatey by running: choco install vscode . Others Refer to the Visual Studio Code guide for installing it on other operating systems.","title":"Configuring Visual Studio Code"},{"location":"getting-started/preparation.html#adding-extensions","text":"To enable syntax highlighting and language support for the languages used in this tutorial, VS Code can be configured with these extensions. Erlang . Elixir . Python . sHML syntax highlighting? Versions These distribution versions are used in this tutorial. Your installed versions need not exactly match, but we document these in case of any problems you might face when working through the tutorial later on. Name Version Erlang/ OTP 23.3.2 Elixir 1.11.4 Python 3.9.4 PIP 21.0.1 VS Code 1.56.0 LINK TO NEXT SECTION","title":"Adding extensions"},{"location":"getting-started/quickstart.html","text":"Quickstart \u00b6 Launching detectEr from the shell \u00b6 The detecter/ebin directory created previously needs to be included in the Erlang runtime path to preload all the binaries required to be able to use detectEr. This is done by using the -pa switch when launching the Erlang shell. [duncan@local]:$ erl -pa /path/to/detecter/ebin Once loaded, detectEr can be used to monitor systems that execute on the Erlang Virtual Machine. It also supports the monitoring of systems that run outside of the EVM , provided that these record their logs in files following a predetermined formatting that enables detectEr to extract runtime information. This topic is covered in more depth in the Instrumentation section. For now, we establish the workflow required to use detectEr by way of the traditional \u2018hello world\u2019 example. Hello world \u00b6 Before using detectEr, you should get an intuitive grasp of what monitoring is, and the steps one needs to follow to initialise and start the monitoring process. If this is your first time using Erlang, the following wil help you get acquainted with the Erlang shell. Launch a new terminal emulator window ( e.g. Terminal on Ubuntu or macOS), navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. BEAM files are (fairly) portable binaries consisting of bytecode that is interpreted by the EVM , similar to how Java operates. [duncan@local]:/detecter/examples/erlang$ make rm -f ebin/*.beam ebin/*.E ebin/*.tmp erl_crash.dump ebin/*.app ... [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 7 duncan duncan 224 May 17 17:16 ebin drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src 3. Launch the Erlang shell erl . We add the binaries of the ebin directory to the Erlang code path via the -pa flag to load and make them accessible from the shell. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> 4. The Erlang shell allows you to type expressions and execute them by pressing Enter . Every expression typed on the shell must be terminated with a full-stop. Try invoking the function greet of the hello module. The function greet accepts one argument, the name of the person to greet, specified as a string enclosed within double quotes. 1 > hello : greet ( \"Duncan\" ). Hello there , Duncan ! ok 2 > 5. Quit the Erlang shell by typing q(). Function signatures In Erlang (and Elixir), functions are uniquely identified via the triple mod : fun / arity , where mod is the module name, fun , the name of the function contained in the module, and arity , the number of arguments that the function accepts. This reference format is commonly known as MFA . For example, our greet function inside the module hello can be concisely referred to as hello : greet / 1 . We refer to functions in the same module simply as fun / arity . Hello world, the asynchronous way \u00b6 You might have noticed that hello : greet / 1 pauses the Erlang shell momentarily before the greeting is displayed. During this interval, the shell is inoperable and cannot accept user input. Such function calls are called synchronous invocations, since they block the caller until the called function returns, i.e. the body of the called function is executed in its entirety and a value is returned to the caller. Examining the body of greet below makes it clear why the Erlang shell stops responding when the function call is effected. 1 2 3 greet ( Name ) -> timer : sleep ( 5000 ), % Pause for 5 seconds to simulate some work.. io : format ( \"Hello there, ~s ! ~n \" , [ Name ]). Line 1 defines the function greet that accepts Name as parameter, while line 3 prints the greeting on the Erlang shell via call to io : format / 2 . The call timer : sleep ( 5000 ) on line 2 pauses the caller process ( i.e. the Erlang shell, in this case) for 5000 ms before executing the rest of the function body. In Erlang, the function return value is the result of the last expression in the function body; for the case of greet , this value is the atom ok that is returned by io : format / 2 . Synchronous calls Synchronous function calls are useful when one needs to ensure that certain processes execute in some prescribed order with respect to one another, e.g. in lock step. This mode of interaction is common to many standard communication protocols such as HTTP , SMTP , DNS , etc. Unwanted synchrony can be easily avoided by launching functions to execute as independent processes that run concurrently with other processes in the system. To this end, Erlang provides the Built-in Functions spawn / { 1 - 4 } , and their variations . We slightly tweak our hello world example to spawn hello : greet / 1 as a separate process that executes concurrently with the Erlang shell process. 4 5 start_greet ( Name ) when is_list ( Name ) -> spawn ( ? MODULE , greet , [ Name ]). The function start_greet / 1 implements this modification. It uses the BIF spawn / 3 (line 5 ) to launch hello : greet / 1 as a process, returning the new process ID. Process IDs ( PIDs for short) are triples of the form < A . B . C > that uniquely identify Erlang processes executing on the EVM . spawn / 3 is parametrised by the module name, the name of the function to spawn, and the list of arguments accepted by the function. Function start_greet / 1 makes use of the predefined macro ? MODULE , that gets replaced with the name of the module it appears in when the source code of the hello module is preprocessed by the Erlang compiler. Concretely, the invocation to spawn/3 on line 5 yields the source code spawn ( hello , greet , [ Name ]) prior to compilation. Restart the Erlang shell and invoke hello : start_greet / 1 . 1 > hello : start_greet ( \"Duncan\" ). < 0 . 97 . 0 > Hello there , Duncan ! % Shown after a slight pause. 2 > Observe that now: The return value of start_greet is the PID of the spawned process < 0 . 97 . 0 > instead of the atom ok ; The Erlang shell does not block, but returns immediately; After the predefined sleep time elapses, the greeting is printed to the shell. Outline runtime monitoring \u00b6 In this quickstart demo, we monitor the execution of our asynchronous hello world example using the outline form of instrumentation. Launch the shell as previous, adding the hello world binaries in ebin to the Erlang code path. The detectEr binaries compiled earlier are also included. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> Compile the sample prop_hello.hml property script to generate the corresponding analyser binary. 1 > hml_eval : compile ( \"props/prop_hello.hml\" , [{ outdir , \"ebin\" }, v ]). This compilation procedure, known as the synthesis , translates sHML specifications written in *.hml script files to their analyser equivalents. For now, it suffices to know that sHML \u2014the logic used by detectEr\u2014expresses properties of the system one wishes to runtime verify. Our analyser Erlang binary generated from the sample property is placed in /detecter/examples/erlang/ebin and automatically loaded for use in the shell code path. 2 > ls ( \"ebin\" ). hello . beam prop_hello . beam ... The analyser prop_hello exposes a single function, mfa_spec / 1 , that accepts the MFArgs triple { Mod , Fun , Args } designating the Erlang process to be analysed. Specifically, Mod , Fun and Args are the components of the function passed as arguments to spawn / 3 . For our hello world example, Mod is the atom hello , Fun is the function name greet , and Args , the singleton argument list containing the name of the person to be greeted. You can test prop_hello : mfa_spec / 1 analyser function by providing the triple { hello , greet , [ \"Duncan\" ]} . 3 > prop_hello : mfa_spec ({ hello , greet ,[ \"Duncan\" ]}). *** [ < 0 . 82 . 0 > ] Instrumenting monitor for MFA pattern '{hello,greet,[\"Duncan\"]}' . *** [ < 0 . 82 . 0 > ] Reached verdict 'no' . Launch the monitored system. 4 > monitor : start_online ({ hello , start_greet ,[ \"Duncan\" ]}, fun prop_hello : mfa_spec / 1 , []). The function monitor : start_online / 3 accepts three arguments: a MFArgs describing the function that is to be spawned as an Erlang process, the analyser function, and a list of options . Setting MFArgs to { hello , start_greet ,[ \"Duncan\" ]} and the analyser to fun prop_hello : mfa_spec / 1 launches the hello world and analyser processes to execute concurrently. In this introductory example, the analyser prop_hello promptly terminates with the verdict no as soon as our hello world program starts executing. The no verdict informs us that a program has violated the specification of prop_hello.hml . We next look at a typical concurrent program where processes interact, and study what kind of useful properties one might want such systems to observe.","title":"Quickstart"},{"location":"getting-started/quickstart.html#quickstart","text":"","title":"Quickstart"},{"location":"getting-started/quickstart.html#launching-detecter-from-the-shell","text":"The detecter/ebin directory created previously needs to be included in the Erlang runtime path to preload all the binaries required to be able to use detectEr. This is done by using the -pa switch when launching the Erlang shell. [duncan@local]:$ erl -pa /path/to/detecter/ebin Once loaded, detectEr can be used to monitor systems that execute on the Erlang Virtual Machine. It also supports the monitoring of systems that run outside of the EVM , provided that these record their logs in files following a predetermined formatting that enables detectEr to extract runtime information. This topic is covered in more depth in the Instrumentation section. For now, we establish the workflow required to use detectEr by way of the traditional \u2018hello world\u2019 example.","title":"Launching detectEr from the shell"},{"location":"getting-started/quickstart.html#hello-world","text":"Before using detectEr, you should get an intuitive grasp of what monitoring is, and the steps one needs to follow to initialise and start the monitoring process. If this is your first time using Erlang, the following wil help you get acquainted with the Erlang shell. Launch a new terminal emulator window ( e.g. Terminal on Ubuntu or macOS), navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. BEAM files are (fairly) portable binaries consisting of bytecode that is interpreted by the EVM , similar to how Java operates. [duncan@local]:/detecter/examples/erlang$ make rm -f ebin/*.beam ebin/*.E ebin/*.tmp erl_crash.dump ebin/*.app ... [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 7 duncan duncan 224 May 17 17:16 ebin drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src 3. Launch the Erlang shell erl . We add the binaries of the ebin directory to the Erlang code path via the -pa flag to load and make them accessible from the shell. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> 4. The Erlang shell allows you to type expressions and execute them by pressing Enter . Every expression typed on the shell must be terminated with a full-stop. Try invoking the function greet of the hello module. The function greet accepts one argument, the name of the person to greet, specified as a string enclosed within double quotes. 1 > hello : greet ( \"Duncan\" ). Hello there , Duncan ! ok 2 > 5. Quit the Erlang shell by typing q(). Function signatures In Erlang (and Elixir), functions are uniquely identified via the triple mod : fun / arity , where mod is the module name, fun , the name of the function contained in the module, and arity , the number of arguments that the function accepts. This reference format is commonly known as MFA . For example, our greet function inside the module hello can be concisely referred to as hello : greet / 1 . We refer to functions in the same module simply as fun / arity .","title":"Hello world"},{"location":"getting-started/quickstart.html#hello-world-the-asynchronous-way","text":"You might have noticed that hello : greet / 1 pauses the Erlang shell momentarily before the greeting is displayed. During this interval, the shell is inoperable and cannot accept user input. Such function calls are called synchronous invocations, since they block the caller until the called function returns, i.e. the body of the called function is executed in its entirety and a value is returned to the caller. Examining the body of greet below makes it clear why the Erlang shell stops responding when the function call is effected. 1 2 3 greet ( Name ) -> timer : sleep ( 5000 ), % Pause for 5 seconds to simulate some work.. io : format ( \"Hello there, ~s ! ~n \" , [ Name ]). Line 1 defines the function greet that accepts Name as parameter, while line 3 prints the greeting on the Erlang shell via call to io : format / 2 . The call timer : sleep ( 5000 ) on line 2 pauses the caller process ( i.e. the Erlang shell, in this case) for 5000 ms before executing the rest of the function body. In Erlang, the function return value is the result of the last expression in the function body; for the case of greet , this value is the atom ok that is returned by io : format / 2 . Synchronous calls Synchronous function calls are useful when one needs to ensure that certain processes execute in some prescribed order with respect to one another, e.g. in lock step. This mode of interaction is common to many standard communication protocols such as HTTP , SMTP , DNS , etc. Unwanted synchrony can be easily avoided by launching functions to execute as independent processes that run concurrently with other processes in the system. To this end, Erlang provides the Built-in Functions spawn / { 1 - 4 } , and their variations . We slightly tweak our hello world example to spawn hello : greet / 1 as a separate process that executes concurrently with the Erlang shell process. 4 5 start_greet ( Name ) when is_list ( Name ) -> spawn ( ? MODULE , greet , [ Name ]). The function start_greet / 1 implements this modification. It uses the BIF spawn / 3 (line 5 ) to launch hello : greet / 1 as a process, returning the new process ID. Process IDs ( PIDs for short) are triples of the form < A . B . C > that uniquely identify Erlang processes executing on the EVM . spawn / 3 is parametrised by the module name, the name of the function to spawn, and the list of arguments accepted by the function. Function start_greet / 1 makes use of the predefined macro ? MODULE , that gets replaced with the name of the module it appears in when the source code of the hello module is preprocessed by the Erlang compiler. Concretely, the invocation to spawn/3 on line 5 yields the source code spawn ( hello , greet , [ Name ]) prior to compilation. Restart the Erlang shell and invoke hello : start_greet / 1 . 1 > hello : start_greet ( \"Duncan\" ). < 0 . 97 . 0 > Hello there , Duncan ! % Shown after a slight pause. 2 > Observe that now: The return value of start_greet is the PID of the spawned process < 0 . 97 . 0 > instead of the atom ok ; The Erlang shell does not block, but returns immediately; After the predefined sleep time elapses, the greeting is printed to the shell.","title":"Hello world, the asynchronous way"},{"location":"getting-started/quickstart.html#outline-runtime-monitoring","text":"In this quickstart demo, we monitor the execution of our asynchronous hello world example using the outline form of instrumentation. Launch the shell as previous, adding the hello world binaries in ebin to the Erlang code path. The detectEr binaries compiled earlier are also included. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> Compile the sample prop_hello.hml property script to generate the corresponding analyser binary. 1 > hml_eval : compile ( \"props/prop_hello.hml\" , [{ outdir , \"ebin\" }, v ]). This compilation procedure, known as the synthesis , translates sHML specifications written in *.hml script files to their analyser equivalents. For now, it suffices to know that sHML \u2014the logic used by detectEr\u2014expresses properties of the system one wishes to runtime verify. Our analyser Erlang binary generated from the sample property is placed in /detecter/examples/erlang/ebin and automatically loaded for use in the shell code path. 2 > ls ( \"ebin\" ). hello . beam prop_hello . beam ... The analyser prop_hello exposes a single function, mfa_spec / 1 , that accepts the MFArgs triple { Mod , Fun , Args } designating the Erlang process to be analysed. Specifically, Mod , Fun and Args are the components of the function passed as arguments to spawn / 3 . For our hello world example, Mod is the atom hello , Fun is the function name greet , and Args , the singleton argument list containing the name of the person to be greeted. You can test prop_hello : mfa_spec / 1 analyser function by providing the triple { hello , greet , [ \"Duncan\" ]} . 3 > prop_hello : mfa_spec ({ hello , greet ,[ \"Duncan\" ]}). *** [ < 0 . 82 . 0 > ] Instrumenting monitor for MFA pattern '{hello,greet,[\"Duncan\"]}' . *** [ < 0 . 82 . 0 > ] Reached verdict 'no' . Launch the monitored system. 4 > monitor : start_online ({ hello , start_greet ,[ \"Duncan\" ]}, fun prop_hello : mfa_spec / 1 , []). The function monitor : start_online / 3 accepts three arguments: a MFArgs describing the function that is to be spawned as an Erlang process, the analyser function, and a list of options . Setting MFArgs to { hello , start_greet ,[ \"Duncan\" ]} and the analyser to fun prop_hello : mfa_spec / 1 launches the hello world and analyser processes to execute concurrently. In this introductory example, the analyser prop_hello promptly terminates with the verdict no as soon as our hello world program starts executing. The no verdict informs us that a program has violated the specification of prop_hello.hml . We next look at a typical concurrent program where processes interact, and study what kind of useful properties one might want such systems to observe.","title":"Outline runtime monitoring"},{"location":"getting-started/setting-up-detecter.html","text":"Setting up detectEr \u00b6 Downloading detectEr \u00b6 detectEr can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling and testing detectEr examples Tutorial examples erlang Calculator server implementation in Erlang src Erlang module sources props sHML property specifications Makefile Makefile with targets for compiling the example elixir Calculator server implementation in Elixir lib Elixir module sources props sHML property specifications Makefile Makefile with targets for compiling the example python Calculator server implementation in Python using TCP sockets src Python script sources props sHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license Compiling detectEr \u00b6 For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential package which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules as *.beam executables. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr LINK TO NEXT SECTION","title":"Setting up detectEr"},{"location":"getting-started/setting-up-detecter.html#setting-up-detecter","text":"","title":"Setting up detectEr"},{"location":"getting-started/setting-up-detecter.html#downloading-detecter","text":"detectEr can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling and testing detectEr examples Tutorial examples erlang Calculator server implementation in Erlang src Erlang module sources props sHML property specifications Makefile Makefile with targets for compiling the example elixir Calculator server implementation in Elixir lib Elixir module sources props sHML property specifications Makefile Makefile with targets for compiling the example python Calculator server implementation in Python using TCP sockets src Python script sources props sHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license","title":"Downloading detectEr"},{"location":"getting-started/setting-up-detecter.html#compiling-detecter","text":"For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential package which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules as *.beam executables. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr LINK TO NEXT SECTION","title":"Compiling detectEr"},{"location":"using-detecter/formalising-properties.html","text":"Formalising Properties \u00b6 Choosing what to analyse \u00b6 detectEr provides the keywords with and monitor to target program processes for a particular sHML specification. The with keyword picks out the signature of the function that is spawned as a process, whereas the monitor keyword defines the property to be runtime analysed. For example, to verify the behaviour of our calculator process against the formula above , we write: against the formula from earlier, xxxx with calc_server : loop (_) monitor and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff From an instrumentation standpoint, with establishes the set of trace event corresponding to the program process it targets, thus enabling the specification to abstract from the events that are generated by other processes. This helps maintain the size of sHML specifications compact whenever possible. In using with , our formula need not account for superfluous trace events ( e.g. of another calculator process) that tend to make the specification exercise tedious and error-prone. Explain the init event that every process performs. INSERT MODEL. Formalising P 1 \u00b6 Specify a simple property and explain the synthesised code, giving an example of how the events are consumed and processed. Probably it will be the first property in the paper or else, the second one for which we have the automaton and we can show the corresponding code generated in Erlang. An alternative to P 1 \u00b6 The property of request count, but instead of the exit event use the init event of the process. Formalising P 2 \u00b6 Formalising P 3 \u00b6","title":"Formalising Properties"},{"location":"using-detecter/formalising-properties.html#formalising-properties","text":"","title":"Formalising Properties"},{"location":"using-detecter/formalising-properties.html#choosing-what-to-analyse","text":"detectEr provides the keywords with and monitor to target program processes for a particular sHML specification. The with keyword picks out the signature of the function that is spawned as a process, whereas the monitor keyword defines the property to be runtime analysed. For example, to verify the behaviour of our calculator process against the formula above , we write: against the formula from earlier, xxxx with calc_server : loop (_) monitor and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff From an instrumentation standpoint, with establishes the set of trace event corresponding to the program process it targets, thus enabling the specification to abstract from the events that are generated by other processes. This helps maintain the size of sHML specifications compact whenever possible. In using with , our formula need not account for superfluous trace events ( e.g. of another calculator process) that tend to make the specification exercise tedious and error-prone. Explain the init event that every process performs. INSERT MODEL.","title":"Choosing what to analyse"},{"location":"using-detecter/formalising-properties.html#formalising-p1","text":"Specify a simple property and explain the synthesised code, giving an example of how the events are consumed and processed. Probably it will be the first property in the paper or else, the second one for which we have the automaton and we can show the corresponding code generated in Erlang.","title":"Formalising P1"},{"location":"using-detecter/formalising-properties.html#an-alternative-to-p1","text":"The property of request count, but instead of the exit event use the init event of the process.","title":"An alternative to P1"},{"location":"using-detecter/formalising-properties.html#formalising-p2","text":"","title":"Formalising P2"},{"location":"using-detecter/formalising-properties.html#formalising-p3","text":"","title":"Formalising P3"},{"location":"using-detecter/getting-started.html","text":"Getting Started \u00b6 A Calculator program in Erlang \u00b6 Let us consider an archetypal calculator program consisting of a single server process that handles client requests for arithmetic computation. The calculator server blocks and waits for requests sent as asynchronous messages. These messages are addressed to the server using its PID , and deposited in the server mailbox that buffers multiple client requests. The calculator server unblocks upon reading a message from its mailbox. In our client-server protocol, messages contain the type of operation to be executed on the server side, its arguments (if applicable), and the client PID to whom the corresponding server reply is addressed. Our calculator program is implemented as the Erlang module calc_server that can be found under examples/erlang/src . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 start ( N ) -> spawn ( ? MODULE , loop , [ N ]). loop ( Tot ) -> receive { Clt , { add , A , B }} -> Clt ! { ok , A + B }, loop ( Tot + 1 ); { Clt , { mul , A , B }} -> Clt ! { ok , A * B }, loop ( Tot + 1 ); { Clt , stp } -> % Stop service. Clt ! { bye , Tot } end . calc_server : loop / 1 encapsulates the calculator server logic that is spawned by some other launcher process ( e.g. the Erlang shell) that invokes calc_server : start / 1 for some integer argument N . The spawned server consumes a message request from its mailbox via the receive expression on lines 5-16 , and pattern matches against one of the three types of operations requested by clients: Addition ( add ) and multiplication ( mul ) requests that carry the operands A and B (lines 6 and 10 ), and, stop ( stp ) requests that carries no arguments (line 14 ). Pattern matching instantiates the variables Clt , A and B to concrete data in client request messages. Every request fulfilled by the server results in a corresponding reply that it sends to the PID of the client instantiated in variable Clt , lines 6 , 10 , and 14 . Server replies carry the status tag (an atom) ok or bye , and the result of the requested operation. The server uses the parameter Tot of loop / 1 to track the number of requests serviced, and is returned in reply to a stp operation. After handling add and mul requests, the server executes loop / 1 to recommence the process loop and service the next client request, incrementing the request count accordingly (lines 8 and 12 ); the tail recursive call to loop / 1 is not made for stp requests, and the calculator server process terminates naturally. The logic of loop / 1 induces a server runtime behaviour that can be abstractly described by the transition system model below. @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro);&#xa;@import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt,stp} Srv ? {Clt,stp} Srv:Clt ! {bye,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! {ok,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{A,B}} Srv ? {Clt,{A,B}} Srv:Clt ! {ok,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{A,B}} Srv ? {Clt,{A,B}} Viewer does not support full SVG 1.1 States of the model capture the internal state that the server process can be in at any point during its execution. Transitions between states denote the computational steps of the program that produce visible program events . For instance, the symbolic event Srv ? { Clt , stp } is exhibited by the server loop when the calculator at its initial state Q0 reads a stp request from its mailbox and transitions to Q3 . This transition depicts the computation that loop / 1 performs to receive the stp request, line 5 , and subsequently pattern match it to { Clt , stp } on line 14 . Note that symbolic events in the model capture the set of possible concrete events that the running program can exhibit, e.g. , Srv ? { Clt , stp } describes all events where Srv and Clt range over PIDs , and stp is the atom denoting the stop operation requested by clients. Safety properties \u00b6 There are a number of properties we would like the server behaviour to observe. For example, the server loop does not control the initial value of Tot that an invocation to calc_server : start / 1 provides. We could, therefore, require that: (P 1 ) The service request count returned on shutdown is never negative. Similarly, we would expect that (P 2 ) Replies are always sent to the client indicated in the request, and that \u201cA request for adding two numbers always returns their sum\u201d both hold, amongst others. These properties are data-dependent , which makes them hard to ascertain using static techniques such as type systems. Besides properties that reason about data, our server logic is expected to comply with control properties, such as, (P 3 ) Client requests are never serviced more than once. The properties mentioned thus far phrase the correctness requirement as a guarantee that the program must always provide. Such properties are called safety properties , since they stipulate that \u201cfor any sort of behaviour that the program can do, nothing bad ever happens.\u201d As a consequence of this condition, showing that a program violates a safety property entails finding just one instance of a program execution that exhibits bad behaviour. Producing this evidence is enough of a proof that the program under scrutiny is not safe with respect to the property in question. The next section explains how these properties can be expressed in a logic that precisely and unambiguously establishes the behaviour programs must comply with.","title":"Getting Started"},{"location":"using-detecter/getting-started.html#getting-started","text":"","title":"Getting Started"},{"location":"using-detecter/getting-started.html#a-calculator-program-in-erlang","text":"Let us consider an archetypal calculator program consisting of a single server process that handles client requests for arithmetic computation. The calculator server blocks and waits for requests sent as asynchronous messages. These messages are addressed to the server using its PID , and deposited in the server mailbox that buffers multiple client requests. The calculator server unblocks upon reading a message from its mailbox. In our client-server protocol, messages contain the type of operation to be executed on the server side, its arguments (if applicable), and the client PID to whom the corresponding server reply is addressed. Our calculator program is implemented as the Erlang module calc_server that can be found under examples/erlang/src . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 start ( N ) -> spawn ( ? MODULE , loop , [ N ]). loop ( Tot ) -> receive { Clt , { add , A , B }} -> Clt ! { ok , A + B }, loop ( Tot + 1 ); { Clt , { mul , A , B }} -> Clt ! { ok , A * B }, loop ( Tot + 1 ); { Clt , stp } -> % Stop service. Clt ! { bye , Tot } end . calc_server : loop / 1 encapsulates the calculator server logic that is spawned by some other launcher process ( e.g. the Erlang shell) that invokes calc_server : start / 1 for some integer argument N . The spawned server consumes a message request from its mailbox via the receive expression on lines 5-16 , and pattern matches against one of the three types of operations requested by clients: Addition ( add ) and multiplication ( mul ) requests that carry the operands A and B (lines 6 and 10 ), and, stop ( stp ) requests that carries no arguments (line 14 ). Pattern matching instantiates the variables Clt , A and B to concrete data in client request messages. Every request fulfilled by the server results in a corresponding reply that it sends to the PID of the client instantiated in variable Clt , lines 6 , 10 , and 14 . Server replies carry the status tag (an atom) ok or bye , and the result of the requested operation. The server uses the parameter Tot of loop / 1 to track the number of requests serviced, and is returned in reply to a stp operation. After handling add and mul requests, the server executes loop / 1 to recommence the process loop and service the next client request, incrementing the request count accordingly (lines 8 and 12 ); the tail recursive call to loop / 1 is not made for stp requests, and the calculator server process terminates naturally. The logic of loop / 1 induces a server runtime behaviour that can be abstractly described by the transition system model below. @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro);&#xa;@import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt,stp} Srv ? {Clt,stp} Srv:Clt ! {bye,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! {ok,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{A,B}} Srv ? {Clt,{A,B}} Srv:Clt ! {ok,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{A,B}} Srv ? {Clt,{A,B}} Viewer does not support full SVG 1.1 States of the model capture the internal state that the server process can be in at any point during its execution. Transitions between states denote the computational steps of the program that produce visible program events . For instance, the symbolic event Srv ? { Clt , stp } is exhibited by the server loop when the calculator at its initial state Q0 reads a stp request from its mailbox and transitions to Q3 . This transition depicts the computation that loop / 1 performs to receive the stp request, line 5 , and subsequently pattern match it to { Clt , stp } on line 14 . Note that symbolic events in the model capture the set of possible concrete events that the running program can exhibit, e.g. , Srv ? { Clt , stp } describes all events where Srv and Clt range over PIDs , and stp is the atom denoting the stop operation requested by clients.","title":"A Calculator program in Erlang"},{"location":"using-detecter/getting-started.html#safety-properties","text":"There are a number of properties we would like the server behaviour to observe. For example, the server loop does not control the initial value of Tot that an invocation to calc_server : start / 1 provides. We could, therefore, require that: (P 1 ) The service request count returned on shutdown is never negative. Similarly, we would expect that (P 2 ) Replies are always sent to the client indicated in the request, and that \u201cA request for adding two numbers always returns their sum\u201d both hold, amongst others. These properties are data-dependent , which makes them hard to ascertain using static techniques such as type systems. Besides properties that reason about data, our server logic is expected to comply with control properties, such as, (P 3 ) Client requests are never serviced more than once. The properties mentioned thus far phrase the correctness requirement as a guarantee that the program must always provide. Such properties are called safety properties , since they stipulate that \u201cfor any sort of behaviour that the program can do, nothing bad ever happens.\u201d As a consequence of this condition, showing that a program violates a safety property entails finding just one instance of a program execution that exhibits bad behaviour. Producing this evidence is enough of a proof that the program under scrutiny is not safe with respect to the property in question. The next section explains how these properties can be expressed in a logic that precisely and unambiguously establishes the behaviour programs must comply with.","title":"Safety properties"},{"location":"using-detecter/instrumentation.html","text":"Instrumentation \u00b6 Types of instrumentation detecter supports. Diagram of the system architecture. How the same generated analyzer code is used to instrument the Erlang, Elixir and Python setups. Generating the monitor \u00b6 This is a common aspect to all types of instrumentation. Treating it centrally reinforces this fact. Inline instrumentation \u00b6 We reintroduce the erlang system code. The erroneous system here is on P1 Outline instrumentation \u00b6 We introduce the elixir system code. The erroneous system here is on P2. Outline instrumentation \u00b6 We introduce the python system code. The erroneous system here is on P3. As system implementations (for the tutorial), we should have: The good system for all language implementations. The system that violates P1 for just erlang. The system that violates P2 for just elixir. The system that violates P3 for just python, doris! We also need the updated parser.","title":"Instrumentation"},{"location":"using-detecter/instrumentation.html#instrumentation","text":"Types of instrumentation detecter supports. Diagram of the system architecture. How the same generated analyzer code is used to instrument the Erlang, Elixir and Python setups.","title":"Instrumentation"},{"location":"using-detecter/instrumentation.html#generating-the-monitor","text":"This is a common aspect to all types of instrumentation. Treating it centrally reinforces this fact.","title":"Generating the monitor"},{"location":"using-detecter/instrumentation.html#inline-instrumentation","text":"We reintroduce the erlang system code. The erroneous system here is on P1","title":"Inline instrumentation"},{"location":"using-detecter/instrumentation.html#outline-instrumentation","text":"We introduce the elixir system code. The erroneous system here is on P2.","title":"Outline instrumentation"},{"location":"using-detecter/instrumentation.html#outline-instrumentation_1","text":"We introduce the python system code. The erroneous system here is on P3. As system implementations (for the tutorial), we should have: The good system for all language implementations. The system that violates P1 for just erlang. The system that violates P2 for just elixir. The system that violates P3 for just python, doris! We also need the updated parser.","title":"Outline instrumentation"},{"location":"using-detecter/runtime-verification.html","text":"Runtime Verification \u00b6 A partial view of the program model \u00b6 Let us recall the calculator server and its transition model. @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro);&#xa;@import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt,stp} Srv ? {Clt,stp} Srv:Clt ! {bye,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! {ok,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{A,B}} Srv ? {Clt,{A,B}} Srv:Clt ! {ok,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{A,B}} Srv ? {Clt,{A,B}} Viewer does not support full SVG 1.1 DRAW TRACES? * From its initial state Q0 , the transition system modelling the behaviour of calc_server : loop / 1 can follow different paths. This branching structure is induced by the receive expression, which introduces a choice between the clauses to execute depending on the pattern match that succeeds. The transition model thus gives us an exhaustive description of the paths that the calculator server can take at runtime, affording us full visibility about what the program is able do. Notably, this information is available prior to runtime, and is what certain static verification techniques such as model checking rely upon. There are however cases where such approaches cannot be employed, e.g. the program transition model is not available or is infeasible to construct. Runtime Verification is a post-deployment technique [] that can be used instead of\u2014or in tandem with\u2014static techniques to increase correctness assurances about a program under scrutiny. detectEr is a RV tool for asynchronous component systems that can analyse the behaviour of programs running on, or outside the EVM . HERE Often, the runtime setting in constrained to one THE LOGIC SHML IS MONITORABLE WITH RESPECT TO PROGRAM VIOLATIONS. WHY? BECAUSE WE HAVE DISCUSSED THAT TO SHOW A VIOLATION OF THE PROPERTY, WE JUST NEED ONE BAD TRACE, WHICH THERE IS A POSSIBILITY OF FINDING, PROVIDING THE PROGRAM DOES EXHIBIT SUCH AS TRACE. Often, post-deployment verification techniques such as RV , do not have access to the entire execution graph of a SuS, e.g. the transition model in fig. 1b. Instead, these are limited to the trace of (program) events that is generated by the cur- rent execution of the SuS. For instance, an execution might generate the trace of events \u2018pid1 ?\u27e8pid2 ,stp\u27e9.pid1:pid2 !\u27e8bye,\u22121\u27e9\u2019, that corresponds to the (finite) path traversal Q0 \u2192Srv?\u27e8Clt,stp\u27e9\u2192Q3 \u2192Srv:Clt!\u27e8bye,Tot\u27e9\u2192Q4 in the transi- tion model of fig. 1b. In traces, events consist of concrete values instead of vari- able placeholders, e.g. pid1 instead of Srv, etc. Describe what a trace is. Runtime is a different story. A sequential program logic such as loop/1 can only choose one path, which is reflected in the program events exhibits. A path of the model, take from paper. A trace is a path of the model. LINK TO NEXT SECTION In the next section we see how a logic that specifies properties on the transition model of the system can also be used to veriify the system at runtime just by looking at sliver of the model, captured in a path of the trace. Trace events - From model to trace events \u00b6 Full model in the diagram, but partial model at runtime. While the program is a transition system where each program state can simultaneously branch into more than one state, at runtime we only get to observe the program actions in the form of linear sequences of events called traces. Explain how trace events capture the computation of the system. Give an example of trace events in Erlang Say that they carry data List the 5 trace events that we support (so that we link with the logic section)","title":"Runtime Verification"},{"location":"using-detecter/runtime-verification.html#runtime-verification","text":"","title":"Runtime Verification"},{"location":"using-detecter/runtime-verification.html#a-partial-view-of-the-program-model","text":"Let us recall the calculator server and its transition model. @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro);&#xa;@import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt,stp} Srv ? {Clt,stp} Srv:Clt ! {bye,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! {ok,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{A,B}} Srv ? {Clt,{A,B}} Srv:Clt ! {ok,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{A,B}} Srv ? {Clt,{A,B}} Viewer does not support full SVG 1.1 DRAW TRACES? * From its initial state Q0 , the transition system modelling the behaviour of calc_server : loop / 1 can follow different paths. This branching structure is induced by the receive expression, which introduces a choice between the clauses to execute depending on the pattern match that succeeds. The transition model thus gives us an exhaustive description of the paths that the calculator server can take at runtime, affording us full visibility about what the program is able do. Notably, this information is available prior to runtime, and is what certain static verification techniques such as model checking rely upon. There are however cases where such approaches cannot be employed, e.g. the program transition model is not available or is infeasible to construct. Runtime Verification is a post-deployment technique [] that can be used instead of\u2014or in tandem with\u2014static techniques to increase correctness assurances about a program under scrutiny. detectEr is a RV tool for asynchronous component systems that can analyse the behaviour of programs running on, or outside the EVM . HERE Often, the runtime setting in constrained to one THE LOGIC SHML IS MONITORABLE WITH RESPECT TO PROGRAM VIOLATIONS. WHY? BECAUSE WE HAVE DISCUSSED THAT TO SHOW A VIOLATION OF THE PROPERTY, WE JUST NEED ONE BAD TRACE, WHICH THERE IS A POSSIBILITY OF FINDING, PROVIDING THE PROGRAM DOES EXHIBIT SUCH AS TRACE. Often, post-deployment verification techniques such as RV , do not have access to the entire execution graph of a SuS, e.g. the transition model in fig. 1b. Instead, these are limited to the trace of (program) events that is generated by the cur- rent execution of the SuS. For instance, an execution might generate the trace of events \u2018pid1 ?\u27e8pid2 ,stp\u27e9.pid1:pid2 !\u27e8bye,\u22121\u27e9\u2019, that corresponds to the (finite) path traversal Q0 \u2192Srv?\u27e8Clt,stp\u27e9\u2192Q3 \u2192Srv:Clt!\u27e8bye,Tot\u27e9\u2192Q4 in the transi- tion model of fig. 1b. In traces, events consist of concrete values instead of vari- able placeholders, e.g. pid1 instead of Srv, etc. Describe what a trace is. Runtime is a different story. A sequential program logic such as loop/1 can only choose one path, which is reflected in the program events exhibits. A path of the model, take from paper. A trace is a path of the model. LINK TO NEXT SECTION In the next section we see how a logic that specifies properties on the transition model of the system can also be used to veriify the system at runtime just by looking at sliver of the model, captured in a path of the trace.","title":"A partial view of the program model"},{"location":"using-detecter/runtime-verification.html#trace-events-from-model-to-trace-events","text":"Full model in the diagram, but partial model at runtime. While the program is a transition system where each program state can simultaneously branch into more than one state, at runtime we only get to observe the program actions in the form of linear sequences of events called traces. Explain how trace events capture the computation of the system. Give an example of trace events in Erlang Say that they carry data List the 5 trace events that we support (so that we link with the logic section)","title":"Trace events - From model to trace events"},{"location":"using-detecter/synthesising-analysers.html","text":"Explains how to generate analysers using the tool \u00b6 Explains the code and events (and also the code that handles inconclusivity) \u00b6 Must come after the RV section. \u00b6 Inconclusive verdicts and how they work \u00b6 List the possible traces","title":"Explains how to generate analysers using the tool"},{"location":"using-detecter/synthesising-analysers.html#explains-how-to-generate-analysers-using-the-tool","text":"","title":"Explains how to generate analysers using the tool"},{"location":"using-detecter/synthesising-analysers.html#explains-the-code-and-events-and-also-the-code-that-handles-inconclusivity","text":"","title":"Explains the code and events (and also the code that handles inconclusivity)"},{"location":"using-detecter/synthesising-analysers.html#must-come-after-the-rv-section","text":"","title":"Must come after the RV section."},{"location":"using-detecter/synthesising-analysers.html#inconclusive-verdicts-and-how-they-work","text":"List the possible traces","title":"Inconclusive verdicts and how they work"},{"location":"using-detecter/the-specification-logic.html","text":"The Specification Logic \u00b6 Overview \u00b6 For the sake of simplicity, the script hello_prop.hml used in our hello world example specifies a sHML property that every system necessarily violates, namely, the formula ff that denotes falsity. We now look at the full sHML grammar that enables us to express more interesting and useful properties about programs (not traces). Specifications in sHML \u2014also called formulae \u2014are interpreted over the states of transition models of programs we wish to analyse. sHML is a syntactic subset of the more expressive Hennessy-Milner Logic with recursion, and is used to specify safety properties . Recall safety properties state that \u201csomething bad should never happen\u201d. sHML formulae are generated from the following grammar: sHML :: = ff | tt (1) | X (2) | max ( X . sHML ) (3) | and ([ Act ] sHML , ..., [ Act ] sHML ) (4) Formula ff and tt denote falsity and truth respectively, X is a logical variable , The maximal fix-point construct specifies recursion via the logical variable X and binds the free occurrences of X in the sub-formula sHML , and, and (...) is a sequence of comma-separated conjunctions where each conjunct is a sub-formula sHML guarded by the universal modal operator [ Act ] (also called a necessity ). To handle reasoning over program event data, the modal operator is equipped with symbolic actions Act of the form P when C , where P is an event pattern and C , a decidable Boolean constraint . Patterns correspond to events that the program under analysis exhibits. These patterns contain data variables that are instantiated with values learnt at runtime from matched events. Pattern variables bind the free variables in constraints C , and this binding scope extends to the continuation formula sHML . Symbolic action patterns follow the pattern-matching syntax of Erlang and Elixir, where atoms are matched directly, and the \u2018don\u2019t care\u2019 pattern _ matches any data value. We say that a program (or a program state) satisfies the formula [ P when C ] sHML whenever it exhibits an event that matches pattern P , fulfils the constraint C , and the ensuing program behaviour then satisfies sHML . When the constraint is true , the expression when C may be omitted for readability. Pattern and constraint expressions \u00b6 detectEr supports five event patterns describing the lifecycle of processes. A fork action is exhibited by a process when it spawns a new child process; its dual, init , is exhibited by the corresponding child upon initialisation. Process exit actions signal termination, while send and recv describe process interaction. Program event Event pattern Pattern variable Description fork P 1 \u2192 P 2 , Mod : Fun ( Args ) P 1 PID of the parent process spawning P 2 P 2 PID of the child process spawned by P 1 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments init P 1 \u2190 P 2 , Mod : Fun ( Args ) P 1 PID of the parent process spawning P 2 P 2 PID of the child process spawned by P 1 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments exit P 1 ** Data P 1 PID of the terminated process Data Termination data send P 1 : P 2 ! Msg P 1 PID of the process issuing the message P 2 PID of the recipient process Msg Message payload recv P 2 ? Msg P 2 PID of the recipient process Msg Request payload consisting of data The variables P 1 and P 2 in event patterns must be a port ID or PID , whereas Data and Msg may be any Erlang data type , i.e. , one of atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Mod and Fun must be atoms, and Args , an arbitrary list comprised of the aforementioned data types. Pattern matching Our current detectEr syntax does not yet implement full Erlang pattern matching, including $, map, record and bit string expressions; these will be added in future releases of the tool. Note that these data values can still be used in patterns, so long as the pattern matching expression does not unwrap the individual data components of these values. For instance, the pattern Var = Map is acceptable whereas #{K := V} = Map is not; similarly, Var = List may be used but not [$d, $a | _] = List . Constraint definitions on pattern variables used by detectEr correspond to Erlang guard sequences consisting of guard expressions . The set of valid Erlang guards supported by detectEr are the following: Variables. Values, i.e. , atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Expressions constructing atoms, integer, floats, lists, and tuples. Term comparisons. Operator Description == Equal to /= Not equal to =< Less than or equal to < Less than >= Greater than or equal to > Greater than =:= Exactly equal to =/= Exactly not equal to Arithmetic expressions. Operator Description Argument Type + Unary addition Number - Unary subtraction Number + Addition Number - Subtraction Number * Multiplication Number / Floating point division Number bnot Unary bitwise NOT Integer div Integer division Integer rem Integer remainder of X/Y Integer band Bitwise AND Integer bor Bitwise OR Integer bxor Arithmetic bitwise XOR Integer bsl Arithmetic bit shift left Integer bsr Bit shift right Integer Boolean expressions. Operator Description not Unary logical NOT and Logical AND or Logical OR xor Logical XOR Short-circuit expressions andalso , orelse . Suppressing program actions \u00b6 Let us try to specify a safety requirement on the behaviour of our calculator program . The sHML formula with symbolic action Srv:Clt ! {bye,Tot} when Tot < 0 describes the property requiring that \u201cthe program state does not exhibit the send event whose payload consists of { bye , Tot } with a negative total: and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff Recall that the universal modality states that, for any program event satisfying the symbolic action P when C in [ P when C ] sHML , the ensuing program behaviour must then satisfy the continuation formula sHML . However, no program state can satisfy the continuation ff ! This means that the formula and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff can only be satisfied when our calculator program does not exhibit the event described by the symbolic action Srv : Clt ! { bye , Tot } when Tot < 0 . Suppose our server with PID < 0 . 10 . 0 > exhibits the send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , - 1 } in response to a request issued by a client with PID < 0 . 16 . 0 > . It matches pattern Srv : Clt ! { bye , Tot } , instantiating the variables Srv = < 0 . 10 . 0 > , Clt = < 0 . 16 . 0 > , and Tot = - 1 . The constraint when Tot < 0 is also satisfied by Tot , leading to a violation, i.e. , ff . For a different send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , 1 } , the symbolic action in the modality [ Srv : Clt ! { bye , Tot } when Tot < 0 ] is not satisfied, and consequently, and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff is not violated. Analogously, the exit event < 0 . 10 . 0 > ** killed does not lead to a violation of the formula since the pattern Srv : Clt ! { bye , Tot } fails to match the event shape. Cheat sheet The formula [ Act ] ff means that the program must not exhibit the symbolic action Act . LINK TO NEXT SECTION","title":"The Specification Logic"},{"location":"using-detecter/the-specification-logic.html#the-specification-logic","text":"","title":"The Specification Logic"},{"location":"using-detecter/the-specification-logic.html#overview","text":"For the sake of simplicity, the script hello_prop.hml used in our hello world example specifies a sHML property that every system necessarily violates, namely, the formula ff that denotes falsity. We now look at the full sHML grammar that enables us to express more interesting and useful properties about programs (not traces). Specifications in sHML \u2014also called formulae \u2014are interpreted over the states of transition models of programs we wish to analyse. sHML is a syntactic subset of the more expressive Hennessy-Milner Logic with recursion, and is used to specify safety properties . Recall safety properties state that \u201csomething bad should never happen\u201d. sHML formulae are generated from the following grammar: sHML :: = ff | tt (1) | X (2) | max ( X . sHML ) (3) | and ([ Act ] sHML , ..., [ Act ] sHML ) (4) Formula ff and tt denote falsity and truth respectively, X is a logical variable , The maximal fix-point construct specifies recursion via the logical variable X and binds the free occurrences of X in the sub-formula sHML , and, and (...) is a sequence of comma-separated conjunctions where each conjunct is a sub-formula sHML guarded by the universal modal operator [ Act ] (also called a necessity ). To handle reasoning over program event data, the modal operator is equipped with symbolic actions Act of the form P when C , where P is an event pattern and C , a decidable Boolean constraint . Patterns correspond to events that the program under analysis exhibits. These patterns contain data variables that are instantiated with values learnt at runtime from matched events. Pattern variables bind the free variables in constraints C , and this binding scope extends to the continuation formula sHML . Symbolic action patterns follow the pattern-matching syntax of Erlang and Elixir, where atoms are matched directly, and the \u2018don\u2019t care\u2019 pattern _ matches any data value. We say that a program (or a program state) satisfies the formula [ P when C ] sHML whenever it exhibits an event that matches pattern P , fulfils the constraint C , and the ensuing program behaviour then satisfies sHML . When the constraint is true , the expression when C may be omitted for readability.","title":"Overview"},{"location":"using-detecter/the-specification-logic.html#pattern-and-constraint-expressions","text":"detectEr supports five event patterns describing the lifecycle of processes. A fork action is exhibited by a process when it spawns a new child process; its dual, init , is exhibited by the corresponding child upon initialisation. Process exit actions signal termination, while send and recv describe process interaction. Program event Event pattern Pattern variable Description fork P 1 \u2192 P 2 , Mod : Fun ( Args ) P 1 PID of the parent process spawning P 2 P 2 PID of the child process spawned by P 1 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments init P 1 \u2190 P 2 , Mod : Fun ( Args ) P 1 PID of the parent process spawning P 2 P 2 PID of the child process spawned by P 1 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments exit P 1 ** Data P 1 PID of the terminated process Data Termination data send P 1 : P 2 ! Msg P 1 PID of the process issuing the message P 2 PID of the recipient process Msg Message payload recv P 2 ? Msg P 2 PID of the recipient process Msg Request payload consisting of data The variables P 1 and P 2 in event patterns must be a port ID or PID , whereas Data and Msg may be any Erlang data type , i.e. , one of atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Mod and Fun must be atoms, and Args , an arbitrary list comprised of the aforementioned data types. Pattern matching Our current detectEr syntax does not yet implement full Erlang pattern matching, including $, map, record and bit string expressions; these will be added in future releases of the tool. Note that these data values can still be used in patterns, so long as the pattern matching expression does not unwrap the individual data components of these values. For instance, the pattern Var = Map is acceptable whereas #{K := V} = Map is not; similarly, Var = List may be used but not [$d, $a | _] = List . Constraint definitions on pattern variables used by detectEr correspond to Erlang guard sequences consisting of guard expressions . The set of valid Erlang guards supported by detectEr are the following: Variables. Values, i.e. , atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Expressions constructing atoms, integer, floats, lists, and tuples. Term comparisons. Operator Description == Equal to /= Not equal to =< Less than or equal to < Less than >= Greater than or equal to > Greater than =:= Exactly equal to =/= Exactly not equal to Arithmetic expressions. Operator Description Argument Type + Unary addition Number - Unary subtraction Number + Addition Number - Subtraction Number * Multiplication Number / Floating point division Number bnot Unary bitwise NOT Integer div Integer division Integer rem Integer remainder of X/Y Integer band Bitwise AND Integer bor Bitwise OR Integer bxor Arithmetic bitwise XOR Integer bsl Arithmetic bit shift left Integer bsr Bit shift right Integer Boolean expressions. Operator Description not Unary logical NOT and Logical AND or Logical OR xor Logical XOR Short-circuit expressions andalso , orelse .","title":"Pattern and constraint expressions"},{"location":"using-detecter/the-specification-logic.html#suppressing-program-actions","text":"Let us try to specify a safety requirement on the behaviour of our calculator program . The sHML formula with symbolic action Srv:Clt ! {bye,Tot} when Tot < 0 describes the property requiring that \u201cthe program state does not exhibit the send event whose payload consists of { bye , Tot } with a negative total: and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff Recall that the universal modality states that, for any program event satisfying the symbolic action P when C in [ P when C ] sHML , the ensuing program behaviour must then satisfy the continuation formula sHML . However, no program state can satisfy the continuation ff ! This means that the formula and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff can only be satisfied when our calculator program does not exhibit the event described by the symbolic action Srv : Clt ! { bye , Tot } when Tot < 0 . Suppose our server with PID < 0 . 10 . 0 > exhibits the send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , - 1 } in response to a request issued by a client with PID < 0 . 16 . 0 > . It matches pattern Srv : Clt ! { bye , Tot } , instantiating the variables Srv = < 0 . 10 . 0 > , Clt = < 0 . 16 . 0 > , and Tot = - 1 . The constraint when Tot < 0 is also satisfied by Tot , leading to a violation, i.e. , ff . For a different send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , 1 } , the symbolic action in the modality [ Srv : Clt ! { bye , Tot } when Tot < 0 ] is not satisfied, and consequently, and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff is not violated. Analogously, the exit event < 0 . 10 . 0 > ** killed does not lead to a violation of the formula since the pattern Srv : Clt ! { bye , Tot } fails to match the event shape. Cheat sheet The formula [ Act ] ff means that the program must not exhibit the symbolic action Act . LINK TO NEXT SECTION","title":"Suppressing program actions"}]}